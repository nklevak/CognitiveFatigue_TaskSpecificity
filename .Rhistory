final_df <- final_df %>%
left_join(bid_vals %>% select(subj_id, curr_block_num, following_bid),
by = c("subj_id","curr_block_num"))
# get average bids per participant
avg_subj_bids <- final_df %>%
filter(trial_type == "survey-text") %>%
group_by(subj_id) %>%
summarise(avg_bids = mean(preceding_bid,na.rm = TRUE),stdev_bids = sd(preceding_bid, na.rm = TRUE)) %>%
ungroup()
final_df <- final_df %>%
left_join(avg_subj_bids, by = "subj_id")
# make a column that represents how different (in stdev) the amount they want to switch is from their mean
final_df <- final_df %>%
mutate(preceding_bid_z_score = if_else(stdev_bids == 0, 0,
ifelse(is.na(preceding_bid),0,
((preceding_bid - avg_bids) /
stdev_bids))),
following_bid_z_score = if_else(stdev_bids == 0, 0,
ifelse(is.na(following_bid),0,
((following_bid - avg_bids) / stdev_bids)))) %>%
filter(trial_type != "survey-text") %>%
select(-prevBlockType,-preceding_bid,-following_bid,-avg_bids,-stdev_bids) %>%
rename(block_switched=switch_next_block) %>%
mutate(z_accuracy = ifelse(game_type == "vs",z_accuracy_vs,z_accuracy_sr), z_rt = ifelse(game_type == "vs",z_rt_vs,z_rt_sr)) %>%
select(-z_accuracy_sr, -z_accuracy_vs, -z_rt_sr, -z_rt_vs)
View(final_df)
# Now I will calculate average z accuracy and z rt per block.
avg_spatial_recall <- final_df %>%
filter(game_type == "spatial_recall") %>%
group_by(subj_id, curr_block_num) %>%
summarise(avg_accuracy = mean(z_accuracy),stdev_accuracy = sd(z_accuracy,na.rm = TRUE), avg_rt = mean(z_rt),stdev_rt = sd(z_rt,na.rm = TRUE))%>%
arrange(subj_id,curr_block_num)
avg_vs <- final_df %>%
filter(game_type == "vs") %>%
group_by(subj_id, curr_block_num) %>%
summarise(avg_accuracy = mean(z_accuracy),stdev_accuracy = sd(z_accuracy,na.rm = TRUE), avg_rt = mean(z_rt),stdev_rt = sd(z_rt,na.rm = TRUE))%>%
arrange(subj_id,curr_block_num)
avg_per_block <- bind_rows(avg_spatial_recall, avg_vs) %>%
arrange(subj_id, curr_block_num)
total_data <- final_df %>%
left_join(avg_per_block, by = c("subj_id","curr_block_num"))
View(total_data)
# Now I will calculate average z accuracy and z rt per block.
avg_spatial_recall <- final_df %>%
filter(game_type == "spatial_recall") %>%
group_by(subj_id, curr_block_num) %>%
summarise(avg_z_accuracy = mean(z_accuracy),stdev_z_accuracy = sd(z_accuracy,na.rm = TRUE), avg_z_rt = mean(z_rt),stdev_z_rt = sd(z_rt,na.rm = TRUE))%>%
arrange(subj_id,curr_block_num)
avg_vs <- final_df %>%
filter(game_type == "vs") %>%
group_by(subj_id, curr_block_num) %>%
summarise(avg_z_accuracy = mean(z_accuracy),stdev_z_accuracy = sd(z_accuracy,na.rm = TRUE), avg_z_rt = mean(z_rt),stdev_z_rt = sd(z_rt,na.rm = TRUE))%>%
arrange(subj_id,curr_block_num)
avg_per_block <- bind_rows(avg_spatial_recall, avg_vs) %>%
arrange(subj_id, curr_block_num)
total_data <- final_df %>%
left_join(avg_per_block, by = c("subj_id","curr_block_num"))
View(df_all_cleaned)
knitr::opts_chunk$set(echo = TRUE)
library("knitr") # for knitting things
library("tidyverse") # for all things tidyverse
##library(jsonlite)
library("broom")      # for tidying up linear models
library("car")        # for running ANOVAs
library("afex")       # also for running ANOVAs
library("emmeans")    # for calculating constrasts
# set the default ggplot theme
theme_set(theme_classic())
setwd("../../data/pilotC/")
csv_files <- list.files(pattern = "\\.csv$")
# Function to read a CSV file and convert all columns to character type
read_csv_as_character <- function(file) {
df <- read.csv(file, stringsAsFactors = FALSE)
df[] <- lapply(df, as.character)
return(df)
}
df_all <- bind_rows(lapply(csv_files,read_csv_as_character))
anonymize_clean <- function(df) {
df <- df %>%
select(-recorded_at,-ip,-user_agent,-referer,-sequence_length,
-accept_language,-device,-internal_node_id,-view_history,
-source_code_version, -contains("browser"),-contains("platform"),
-contains("screen"),-contains("width"),-contains("height"),
-contains("failed"),-condition,-success,-event_history)
return(df)
}
df_all <- anonymize_clean(df_all)
# save practice to practice_runs_df
practice_runs_df <- df_all %>%
filter(practice == "true")
# save feedback to a df
# make a column for how much they rated vs and sr difficulty and boringness
feedback_df <- df_all %>%
filter(trial_type == "survey-text") %>%
filter(str_detect(response, "bid_decision") | str_detect(response, "game_description") | str_detect(response, "boring"))
feedback_df <- feedback_df %>%
mutate(response = map(response, ~ jsonlite::fromJSON(.))) %>%
unnest_wider(response)
feedback_temp_sr <- feedback_df %>%
filter(!is.na(sr_boring)) %>%
select(run_id, sr_boring, sr_difficult)
feedback_temp_vs <- feedback_df %>%
filter(!is.na(vs_boring)) %>%
select(run_id, vs_boring, vs_difficult)
df_all <- merge(df_all, feedback_temp_sr, by = "run_id")
df_all <- merge(df_all, feedback_temp_vs, by = "run_id")
# make a column for average practice score per participant and put it into the main df
temp <- practice_runs_df %>%
select(run_id, trial_type, score_an, correct_trial) %>%
mutate(correct = ifelse(trial_type == "spatial-recall",as.integer(score_an),ifelse(correct_trial=="null",0,as.integer(correct_trial)))) %>%
select(run_id, trial_type, correct) %>%
group_by(run_id, trial_type) %>%
summarise(avg_correct = mean(correct)) %>%
mutate(sr_practice_accuracy = ifelse(trial_type == "spatial-recall",avg_correct,NA),vs_practice_accuracy = ifelse(trial_type != "spatial-recall",avg_correct,NA)) %>%
ungroup() %>%
select(run_id, sr_practice_accuracy, vs_practice_accuracy) %>%
group_by(run_id) %>%
summarise(
sr_practice_accuracy = max(sr_practice_accuracy, na.rm = TRUE),
vs_practice_accuracy = max(vs_practice_accuracy, na.rm = TRUE)
) %>%
ungroup()
df_all <- merge(df_all, temp, by = "run_id")
# remove practice & other non-task rows from df
df_all_cleaned <- df_all %>%
filter(trial_type != "instructions", trial_type != "preload",
trial_type != "survey-multi-choice",
(trial_type != 'html-keyboard-response' | trial_id =='test_trial'),
(trial_type != 'html-button-response'),
!grepl("screen", trial_type, ignore.case = TRUE)) %>%
filter(practice != "true") %>%
mutate(bid_value = as.integer(gsub("[^0-9]+", "", response)))%>%
select(-num_stimuli)
# update correct column for all df_all_cleaned
df_all_cleaned <- df_all_cleaned %>%
mutate(correct = ifelse(trial_type == "spatial-recall",as.integer(score_an, na.rm = TRUE),ifelse(correct_trial=="null",0,as.integer(correct_trial,na.rm=TRUE)))) %>%
select(-score_an, -correct_trial) %>%
ungroup()
# spread bid and blocks completed value onto the entire block
# this new column will be how much the participant bid
sr_practice_num <- 8
sr_per_block <- 10
vs_practice_num <- 16
vs_per_block <- 20
num_blocks <- 13
# Helper function to add a survey-text row if missing
add_survey_text_row <- function(df) {
if (nrow(df) > 0 && df$trial_type[1] != "survey-text") {
new_row <- tibble(
blocks_completed = '0',
switch_next_block = 'false',
trial_type = 'survey-text',
run_id = as.character(df$run_id[1]),
trial_index = '-1'
)
df <- bind_rows(new_row, df)
}
return(df)
}
# Function to process data
process_data <- function(data, per_block) {
data %>%
nest(data = everything()) %>%
mutate(data = map(data, add_survey_text_row)) %>%
unnest(cols = data) %>%
mutate(
switch_next_block = ifelse(switch_next_block == "", NA, switch_next_block),
group = rep(1:(n() %/% (per_block + 1) + 1), each = (per_block + 1), length.out = n())
) %>%
group_by(group) %>%
mutate(switch_next_block = as.character(switch_next_block)) %>%
fill(bid_value, switch_next_block, blocks_completed, .direction = "down") %>%
ungroup() %>%
select(-group, -bonus, -overall_accuracy, -score_pc, -score_ls, correct)
}
# Spatial Recall
sr <- df_all_cleaned %>%
filter(
(prevBlockType == "spatial_recall" & switch_next_block == "false") |
(prevBlockType == "vs" & switch_next_block == "true") |
(game_type == "spatial_recall")
) %>%
group_by(run_id)
sr_final <- sr %>%
group_split(run_id) %>%
map_df(~ process_data(.x, sr_per_block))%>%
mutate(rt_num = as.numeric(rt, na.rm = TRUE))
# Visual Search
vs <- df_all_cleaned %>%
filter(
(prevBlockType == "spatial_recall" & switch_next_block == "true") |
(prevBlockType == "vs" & switch_next_block == "false") |
(game_type == "vs")
) %>%
group_by(run_id)
vs_final <- vs %>%
group_split(run_id) %>%
map_df(~ process_data(.x, vs_per_block)) %>%
mutate(rt_num = as.numeric(rt, na.rm = TRUE))
# For each participant for each task, calc average and sd of performance across blocks and of rt
temp <- sr_final %>%
group_by(run_id) %>%
filter(trial_type == "spatial-recall") %>%
summarize(avg_sr_correct = mean(correct, na.rm = TRUE), sd_sr_correct = sd(correct,na.rm = TRUE), avg_sr_rt = mean(rt_num, na.rm=TRUE), sd_sr_rt = sd(rt_num, na.rm=TRUE)) %>%
ungroup()
sr_final <- merge(sr_final, temp, by = "run_id") %>%
ungroup() %>%
mutate(z_accuracy_sr = ifelse(sd_sr_correct != 0, ((correct - avg_sr_correct)/sd_sr_correct), 0), z_rt_sr = ifelse(sd_sr_rt != 0, ((rt_num - avg_sr_rt)/sd_sr_rt),0))
temp <- vs_final %>%
group_by(run_id) %>%
filter(trial_id == "test_trial") %>%
summarize(avg_vs_correct = mean(correct, na.rm = TRUE), sd_vs_correct = sd(correct,na.rm = TRUE), avg_vs_rt = mean(rt_num, na.rm=TRUE), sd_vs_rt = sd(rt_num, na.rm=TRUE)) %>%
ungroup()
vs_final <- merge(vs_final, summary_temp, by = "run_id") %>%
ungroup() %>%
mutate(z_accuracy_vs = ifelse(sd_vs_correct != 0, ((correct - avg_vs_correct)/sd_vs_correct), 0), z_rt_vs = ifelse(sd_vs_rt != 0, ((rt_num - avg_vs_rt)/sd_vs_rt),0))
knitr::opts_chunk$set(echo = TRUE)
library("knitr") # for knitting things
library("tidyverse") # for all things tidyverse
##library(jsonlite)
library("broom")      # for tidying up linear models
library("car")        # for running ANOVAs
library("afex")       # also for running ANOVAs
library("emmeans")    # for calculating constrasts
# set the default ggplot theme
theme_set(theme_classic())
setwd("../../data/pilotC/")
csv_files <- list.files(pattern = "\\.csv$")
# Function to read a CSV file and convert all columns to character type
read_csv_as_character <- function(file) {
df <- read.csv(file, stringsAsFactors = FALSE)
df[] <- lapply(df, as.character)
return(df)
}
df_all <- bind_rows(lapply(csv_files,read_csv_as_character))
anonymize_clean <- function(df) {
df <- df %>%
select(-recorded_at,-ip,-user_agent,-referer,-sequence_length,
-accept_language,-device,-internal_node_id,-view_history,
-source_code_version, -contains("browser"),-contains("platform"),
-contains("screen"),-contains("width"),-contains("height"),
-contains("failed"),-condition,-success,-event_history)
return(df)
}
df_all <- anonymize_clean(df_all)
# save practice to practice_runs_df
practice_runs_df <- df_all %>%
filter(practice == "true")
# save feedback to a df
# make a column for how much they rated vs and sr difficulty and boringness
feedback_df <- df_all %>%
filter(trial_type == "survey-text") %>%
filter(str_detect(response, "bid_decision") | str_detect(response, "game_description") | str_detect(response, "boring"))
feedback_df <- feedback_df %>%
mutate(response = map(response, ~ jsonlite::fromJSON(.))) %>%
unnest_wider(response)
feedback_temp_sr <- feedback_df %>%
filter(!is.na(sr_boring)) %>%
select(run_id, sr_boring, sr_difficult)
feedback_temp_vs <- feedback_df %>%
filter(!is.na(vs_boring)) %>%
select(run_id, vs_boring, vs_difficult)
df_all <- merge(df_all, feedback_temp_sr, by = "run_id")
df_all <- merge(df_all, feedback_temp_vs, by = "run_id")
# make a column for average practice score per participant and put it into the main df
temp <- practice_runs_df %>%
select(run_id, trial_type, score_an, correct_trial) %>%
mutate(correct = ifelse(trial_type == "spatial-recall",as.integer(score_an),ifelse(correct_trial=="null",0,as.integer(correct_trial)))) %>%
select(run_id, trial_type, correct) %>%
group_by(run_id, trial_type) %>%
summarise(avg_correct = mean(correct)) %>%
mutate(sr_practice_accuracy = ifelse(trial_type == "spatial-recall",avg_correct,NA),vs_practice_accuracy = ifelse(trial_type != "spatial-recall",avg_correct,NA)) %>%
ungroup() %>%
select(run_id, sr_practice_accuracy, vs_practice_accuracy) %>%
group_by(run_id) %>%
summarise(
sr_practice_accuracy = max(sr_practice_accuracy, na.rm = TRUE),
vs_practice_accuracy = max(vs_practice_accuracy, na.rm = TRUE)
) %>%
ungroup()
df_all <- merge(df_all, temp, by = "run_id")
# remove practice & other non-task rows from df
df_all_cleaned <- df_all %>%
filter(trial_type != "instructions", trial_type != "preload",
trial_type != "survey-multi-choice",
(trial_type != 'html-keyboard-response' | trial_id =='test_trial'),
(trial_type != 'html-button-response'),
!grepl("screen", trial_type, ignore.case = TRUE)) %>%
filter(practice != "true") %>%
mutate(bid_value = as.integer(gsub("[^0-9]+", "", response)))%>%
select(-num_stimuli)
# update correct column for all df_all_cleaned
df_all_cleaned <- df_all_cleaned %>%
mutate(correct = ifelse(trial_type == "spatial-recall",as.integer(score_an, na.rm = TRUE),ifelse(correct_trial=="null",0,as.integer(correct_trial,na.rm=TRUE)))) %>%
select(-score_an, -correct_trial) %>%
ungroup()
# spread bid and blocks completed value onto the entire block
# this new column will be how much the participant bid
sr_practice_num <- 8
sr_per_block <- 10
vs_practice_num <- 16
vs_per_block <- 20
num_blocks <- 13
# Helper function to add a survey-text row if missing
add_survey_text_row <- function(df) {
if (nrow(df) > 0 && df$trial_type[1] != "survey-text") {
new_row <- tibble(
blocks_completed = '0',
switch_next_block = 'false',
trial_type = 'survey-text',
run_id = as.character(df$run_id[1]),
trial_index = '-1'
)
df <- bind_rows(new_row, df)
}
return(df)
}
# Function to process data
process_data <- function(data, per_block) {
data %>%
nest(data = everything()) %>%
mutate(data = map(data, add_survey_text_row)) %>%
unnest(cols = data) %>%
mutate(
switch_next_block = ifelse(switch_next_block == "", NA, switch_next_block),
group = rep(1:(n() %/% (per_block + 1) + 1), each = (per_block + 1), length.out = n())
) %>%
group_by(group) %>%
mutate(switch_next_block = as.character(switch_next_block)) %>%
fill(bid_value, switch_next_block, blocks_completed, .direction = "down") %>%
ungroup() %>%
select(-group, -bonus, -overall_accuracy, -score_pc, -score_ls, correct)
}
# Spatial Recall
sr <- df_all_cleaned %>%
filter(
(prevBlockType == "spatial_recall" & switch_next_block == "false") |
(prevBlockType == "vs" & switch_next_block == "true") |
(game_type == "spatial_recall")
) %>%
group_by(run_id)
sr_final <- sr %>%
group_split(run_id) %>%
map_df(~ process_data(.x, sr_per_block))%>%
mutate(rt_num = as.numeric(rt, na.rm = TRUE))
# Visual Search
vs <- df_all_cleaned %>%
filter(
(prevBlockType == "spatial_recall" & switch_next_block == "true") |
(prevBlockType == "vs" & switch_next_block == "false") |
(game_type == "vs")
) %>%
group_by(run_id)
vs_final <- vs %>%
group_split(run_id) %>%
map_df(~ process_data(.x, vs_per_block)) %>%
mutate(rt_num = as.numeric(rt, na.rm = TRUE))
# For each participant for each task, calc average and sd of performance across blocks and of rt
temp <- sr_final %>%
group_by(run_id) %>%
filter(trial_type == "spatial-recall") %>%
summarize(avg_sr_correct = mean(correct, na.rm = TRUE), sd_sr_correct = sd(correct,na.rm = TRUE), avg_sr_rt = mean(rt_num, na.rm=TRUE), sd_sr_rt = sd(rt_num, na.rm=TRUE)) %>%
ungroup()
sr_final <- merge(sr_final, temp, by = "run_id") %>%
ungroup() %>%
mutate(z_accuracy_sr = ifelse(sd_sr_correct != 0, ((correct - avg_sr_correct)/sd_sr_correct), 0), z_rt_sr = ifelse(sd_sr_rt != 0, ((rt_num - avg_sr_rt)/sd_sr_rt),0))
temp <- vs_final %>%
group_by(run_id) %>%
filter(trial_id == "test_trial") %>%
summarize(avg_vs_correct = mean(correct, na.rm = TRUE), sd_vs_correct = sd(correct,na.rm = TRUE), avg_vs_rt = mean(rt_num, na.rm=TRUE), sd_vs_rt = sd(rt_num, na.rm=TRUE)) %>%
ungroup()
vs_final <- merge(vs_final, temp, by = "run_id") %>%
ungroup() %>%
mutate(z_accuracy_vs = ifelse(sd_vs_correct != 0, ((correct - avg_vs_correct)/sd_vs_correct), 0), z_rt_vs = ifelse(sd_vs_rt != 0, ((rt_num - avg_vs_rt)/sd_vs_rt),0))
# Combine them all
final_df <- bind_rows(sr_final, vs_final) %>%
mutate(subj_id = as.numeric(run_id), blocks_completed = as.numeric(blocks_completed,na.RM = TRUE)) %>%
select(-run_id,-generated_BDM_value,-question_order) %>%
mutate(curr_block_num = blocks_completed + 1)
final_df <- final_df %>%
group_by(subj_id, game_type) %>%
arrange(subj_id,blocks_completed)
# Clean out columns we don't need anymore
# CAN USE sd_avg_data LATER TO ADD THESE DETAILS BACK IN
extra_data_for_model <- final_df %>%
select(subj_id, game_type, avg_vs_correct, avg_sr_correct, avg_vs_rt, avg_sr_rt, sd_vs_correct, sd_sr_correct, sd_sr_correct, sd_vs_correct, sr_practice_accuracy, vs_practice_accuracy, sr_boring, sr_difficult, vs_boring, vs_difficult, missed_response, sequence, backwards, responses, missed_response, stimulus, time_elapsed, rt, trial_id, trial_duration, stimulus_duration, target_present, correct_response, order_and_color_of_rectangles, target_rectangle_location, ITIParams, numberStim, sd_vs_rt, sd_sr_rt, sr_accuracy, vs_accuracy, choices, exp_stage)
final_df <- final_df %>%
select(-c(avg_vs_correct, avg_sr_correct, avg_vs_rt, avg_sr_rt, sd_vs_correct, sd_sr_correct, sd_sr_correct, sd_vs_correct, sr_practice_accuracy, vs_practice_accuracy, sr_boring, sr_difficult, vs_boring, vs_difficult, missed_response, sequence, backwards, responses, missed_response, stimulus, time_elapsed, rt, trial_id, trial_duration, stimulus_duration, target_present, correct_response, order_and_color_of_rectangles, target_rectangle_location, ITIParams, numberStim, sd_vs_rt, sd_sr_rt, sr_accuracy, vs_accuracy, choices, exp_stage))
final_df <- final_df %>%
arrange(subj_id, curr_block_num) %>%
rename(preceding_bid = bid_value)
bid_vals <- final_df %>%
filter(trial_type == "survey-text") %>%
group_by(subj_id) %>%
arrange(subj_id,blocks_completed) %>%
mutate(following_bid = lead(preceding_bid))
final_df <- final_df %>%
left_join(bid_vals %>% select(subj_id, curr_block_num, following_bid),
by = c("subj_id","curr_block_num"))
# get average bids per participant
avg_subj_bids <- final_df %>%
filter(trial_type == "survey-text") %>%
group_by(subj_id) %>%
summarise(avg_bids = mean(preceding_bid,na.rm = TRUE),stdev_bids = sd(preceding_bid, na.rm = TRUE)) %>%
ungroup()
final_df <- final_df %>%
left_join(avg_subj_bids, by = "subj_id")
# make a column that represents how different (in stdev) the amount they want to switch is from their mean
final_df <- final_df %>%
mutate(preceding_bid_z_score = if_else(stdev_bids == 0, 0,
ifelse(is.na(preceding_bid),0,
((preceding_bid - avg_bids) /
stdev_bids))),
following_bid_z_score = if_else(stdev_bids == 0, 0,
ifelse(is.na(following_bid),0,
((following_bid - avg_bids) / stdev_bids)))) %>%
filter(trial_type != "survey-text") %>%
select(-prevBlockType,-preceding_bid,-following_bid,-avg_bids,-stdev_bids) %>%
rename(block_switched=switch_next_block) %>%
mutate(z_accuracy = ifelse(game_type == "vs",z_accuracy_vs,z_accuracy_sr), z_rt = ifelse(game_type == "vs",z_rt_vs,z_rt_sr)) %>%
select(-z_accuracy_sr, -z_accuracy_vs, -z_rt_sr, -z_rt_vs)
# Now I will calculate average z accuracy and z rt per block.
avg_spatial_recall <- final_df %>%
filter(game_type == "spatial_recall") %>%
group_by(subj_id, curr_block_num) %>%
summarise(avg_z_accuracy = mean(z_accuracy),stdev_z_accuracy = sd(z_accuracy,na.rm = TRUE), avg_z_rt = mean(z_rt),stdev_z_rt = sd(z_rt,na.rm = TRUE))%>%
arrange(subj_id,curr_block_num)
avg_vs <- final_df %>%
filter(game_type == "vs") %>%
group_by(subj_id, curr_block_num) %>%
summarise(avg_z_accuracy = mean(z_accuracy),stdev_z_accuracy = sd(z_accuracy,na.rm = TRUE), avg_z_rt = mean(z_rt),stdev_z_rt = sd(z_rt,na.rm = TRUE))%>%
arrange(subj_id,curr_block_num)
avg_per_block <- bind_rows(avg_spatial_recall, avg_vs) %>%
arrange(subj_id, curr_block_num)
total_data <- final_df %>%
left_join(avg_per_block, by = c("subj_id","curr_block_num"))
View(total_data)
View(total_data)
View(final_df)
subjects_no_spatial_recall <- total_data %>%
group_by(subj_id) %>%
summarize(has_spatial_recall = any(game_type == "spatial_recall")) %>%
filter(!has_spatial_recall)
subjects_no_switch <- total_data %>%
group_by(subj_id) %>%
summarize(has_spatial_recall = any(game_type == "spatial_recall"), has_vs = any(game_type == "vs") %>%
filter(!has_spatial_recall | !has_vs)
head(subjects_no_switch)
subjects_no_switch <- total_data %>%
group_by(subj_id) %>%
summarize(has_spatial_recall = any(game_type == "spatial_recall"), has_vs = any(game_type == "vs") %>%
filter(!has_spatial_recall | !has_vs)
head(subjects_no_switch)
subjects_no_switch <- total_data %>%
group_by(subj_id) %>%
summarize(has_spatial_recall = any(game_type == "spatial_recall"), has_vs = any(game_type == "vs") %>%
filter(!has_spatial_recall | !has_vs)
head(subjects_no_switch)
subjects_no_switch <- total_data %>%
group_by(subj_id) %>%
summarize(has_spatial_recall = any(game_type == "spatial_recall"), has_vs = any(game_type == "vs") %>%
filter(!has_spatial_recall | !has_vs)
head(subjects_no_switch)
subjects_no_switch <- total_data %>%
group_by(subj_id) %>%
summarize(has_spatial_recall = any(game_type == "spatial_recall"), has_vs = any(game_type == "vs")) %>%
filter(!has_spatial_recall | !has_vs)
head(subjects_no_switch)
subjects_no_switch <- total_data %>%
group_by(subj_id) %>%
summarize(has_spatial_recall = any(game_type == "spatial_recall"), has_vs = any(game_type == "vs"))
View(subjects_no_switch)
subjects_no_switch <- total_data %>%
group_by(subj_id) %>%
summarize(has_spatial_recall = any(game_type == "spatial_recall"), has_vs = any(game_type == "vs")) %>%
filter(!has_spatial_recall | !has_vs)
head(subjects_no_switch)
subjects_no_switch <- total_data %>%
group_by(subj_id) %>%
summarize(has_spatial_recall = any(game_type == "spatial_recall"), has_vs = any(game_type == "vs")) %>%
filter(!has_spatial_recall | !has_vs)
head(subjects_no_switch)
excluded_switch_data <- total_data %>%
anti_join(subjects_no_switch, by = "subj_id")
subjects_high_accuracy <- avgs %>%
summarize(min_avg_score = min(overall_game_avg)) %>%
filter(min_avg_score > cutoff)
avgs <- total_data %>%
ungroup() %>%
select(subj_id,game_type, correct) %>%
group_by(subj_id,game_type) %>%
summarize(overall_game_avg = mean(correct_val))
avgs <- total_data %>%
ungroup() %>%
select(subj_id,game_type, correct) %>%
group_by(subj_id,game_type) %>%
summarize(overall_game_avg = mean(correct))
subjects_high_accuracy <- avgs %>%
summarize(min_avg_score = min(overall_game_avg)) %>%
filter(min_avg_score > cutoff)
cutoff = 0.98
avgs <- total_data %>%
ungroup() %>%
select(subj_id,game_type, correct) %>%
group_by(subj_id,game_type) %>%
summarize(overall_game_avg = mean(correct))
subjects_high_accuracy <- avgs %>%
summarize(min_avg_score = min(overall_game_avg)) %>%
filter(min_avg_score > cutoff)
head(subjects_high_accuracy)
excluded_switch_data <- excluded_switch_data %>%
anti_join(subjects_high_accuracy, by = "subj_id")
