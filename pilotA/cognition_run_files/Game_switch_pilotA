// init-jspsych file
var jsPsych = initJsPsych({
    on_finish: function() {
      // Add interactions to the data variable
      // var interaction_data = jsPsych.data.getInteractionData();
      // jsPsych.data.get().addToLast({interactions: interaction_data.json()});
  
      // Display jsPsych data in viewport.
      jsPsych.data.displayData();
    }
  });
  
// gradcpt file//////////////////////////////////////
// EXPERIMENT SET UP VARIABLES
// max number of totalTrialNum_gradcpt = practice trials + num_blocks * gradcpt_trials_per_block
var practice_trials_gradcpt_num = 6
var num_blocks = 4
var gradcpt_trials_per_block = 6
// we will generate a stimuli list for the MAX amount of trials the gradcpt might have (depending on switches, some of these will not be used)
var totalTrialNum_gradcpt = practice_trials_gradcpt_num + num_blocks*gradcpt_trials_per_block

// spatial recall variables;
// EXPERIMENT SET UP VARIABLES
var sr_trials_per_block = 1
var sr_practice_trial_num = 1
var consistent_tile_duration = 300
var grid_size_constant = 5
var digits_to_mem = 5


//////////////////////////////
// STIMULI AND DURATION
var all_stim = ["city_1.jpg","city_2.jpg","city_3.jpg","city_4.jpg", "city_5.jpg","city_6.jpg","mountain_1.jpg",
"c1_c2.gif","c1_c3.gif","c1_c4.gif","c1_c5.gif","c1_c6.gif","c1_m1.gif","c2_c1.gif","c2_c3.gif","c2_c4.gif","c2_c5.gif","c2_c6.gif",
"c2_m1.gif","c3_c1.gif","c3_c2.gif","c3_c4.gif","c3_c5.gif","c3_c6.gif",
"c3_m1.gif","c4_c1.gif","c4_c2.gif","c4_c3.gif","c4_c5.gif","c4_c6.gif",
"c4_m1.gif","c5_c1.gif","c5_c2.gif","c5_c3.gif","c5_c4.gif","c5_c6.gif",
"c5_m1.gif","c6_c1.gif","c6_c2.gif","c6_c3.gif","c6_c4.gif","c6_c5.gif",
"c6_m1.gif","m1_c1.gif","m1_c2.gif","m1_c3.gif","m1_c4.gif","m1_c5.gif"]

let duration_levels_dict = {
    1: 700,2: 680,3: 660,4: 640,5: 620,6: 600,7: 580,8: 560,9: 540,10: 520,11: 500,
}

let stim_dict = {
    '1': 'city_1.jpg','2': 'city_2.jpg','3': 'city_3.jpg','4': 'city_4.jpg','5': 'city_5.jpg','6': 'city_6.jpg',
    '0': 'mountain_1.jpg', '1-0': 'c1_m1.gif','1-2': 'c1_c2.gif','1-3': 'c1_c3.gif','1-4': 'c1_c4.gif','1-5': 'c1_c5.gif',
    '1-6': 'c1_c6.gif','2-0': 'c2_m1.gif','2-1': 'c2_c1.gif','2-3': 'c2_c3.gif','2-4': 'c2_c4.gif','2-5': 'c2_c5.gif',
    '2-6': 'c2_c6.gif','3-0': 'c3_m1.gif','3-1': 'c3_c1.gif','3-2': 'c3_c2.gif','3-4': 'c3_c4.gif',
    '3-5': 'c3_c5.gif','3-6': 'c3_c6.gif','4-0': 'c4_m1.gif','4-1': 'c4_c1.gif','4-2': 'c4_c2.gif',
    '4-3': 'c4_c3.gif', '4-5': 'c4_c5.gif','4-6': 'c4_c6.gif','5-0': 'c5_m1.gif','5-1': 'c5_c1.gif',
    '5-2': 'c5_c2.gif','5-3': 'c5_c3.gif','5-4': 'c5_c4.gif','5-6': 'c5_c6.gif', '6-0': 'c2_m1.gif',
    '6-1': 'c6_c1.gif','6-2': 'c6_c2.gif', '6-3': 'c6_c3.gif','6-4': 'c6_c4.gif','6-5': 'c6_c5.gif',
    '0-1': 'm1_c1.gif','0-2': 'm1_c2.gif','0-3': 'm1_c3.gif','0-4': 'm1_c4.gif','0-5': 'm1_c5.gif',
    '0-6': 'm1_c6.gif'
};

// ORDER OF STIMULI
// this generates a random stimulus list for num_trials, with mountains appearing 10% of the time
// the num_trials inputted here should be for the entire experiment 
var random_stimulus_list = function(num_trials) {
    var prev_trial_index = -1
    let key_stim_list = []
    let final_stim_list = []

    // get the keys with the fillers
    for (let i = 0; i < num_trials; i++) {
        let randomNumber = Math.floor(Math.random() * 10); // Generates a number between 0 and 9

        // prev_trial_index = -1 means this is the first round, so for i = 0, there is just the original picture
        if (prev_trial_index == -1) {
            if (randomNumber == 0) {
                key_stim_list.push(randomNumber.toString()) // starts with mountain
            }
            else { // starts with a city picture
                randomNumber = Math.floor(Math.random() * 6) + 1
                key_stim_list.push(randomNumber.toString()) // number between 1 and 6
            }
            prev_trial_index = randomNumber // update previous trial
            continue
        }

        // for all other rounds, we add the transition from the previous image first, then the new image
        if (randomNumber == 0 && prev_trial_index != 0) { // same trial can't happen in a row
            key_stim_list.push(prev_trial_index + '-' + randomNumber) // add transition to this image
            key_stim_list.push(randomNumber.toString()) // add this image
            prev_trial_index = randomNumber
        } else { 
            if (prev_trial_index == 0) { // if the prior trial was 0 and we get 0 again, we have to give it a num 1 to 6 instead
                randomNumber = Math.floor(Math.random() * 6) + 1 
            } else {
                randomNumber = Math.floor(Math.random() * 5) + 1 
                if (randomNumber >= prev_trial_index) { // random number is 1-6 now (but will not be = to prev trial)
                    randomNumber++;
                }
            }
            key_stim_list.push(prev_trial_index + "-" + randomNumber) // transition to this image
            key_stim_list.push(randomNumber.toString()) // number between 1 and 6 (excluding prev trial), add this image
            prev_trial_index = randomNumber
        }
    }

    // transform the keys into image files
    for (const key of key_stim_list) {
        final_stim_list.push("./img900_esterman/" + stim_dict[key])
    }
    return final_stim_list;
};

// PRELOADING
var preload_stim = []
var path_to_img = "./img900_esterman/"
for (let i = 0; i < all_stim.length; i++) {
    preload_stim.push(path_to_img + all_stim[i]);
}
var preload_auto = {
    type: jsPsychPreload,
    show_detailed_errors: true,
    auto_preload: true,
    message: 'Please wait while the experiment loads. This may take a few minutes.',
};
var preload_manual = {
    type: jsPsychPreload,
    show_detailed_errors: true,
    images: preload_stim,
    message: 'Please wait while the experiment loads. This may take a few minutes.',
};

//////////////////////////////////////////////////////////////////////////////
// DURATION MANIPULATION SECTION (for this pilot version, we do not need auto-titrating for now)
// for this verion, these variables are initialized and exist but don't really mean anything because
// adjust_duration = false
var level_for_all_trials = 2 // this is all that matters in this version since adjust_duration below is false
var curr_trial_duration_level = 1
let max_dur = 11
let min_dur = 1

// GET TRIALS FUNCTION
// each "trial round" is the image being shown, and the following transition
// pass in how many trial timeline rounds you want it to generate, and remove those from the final_list
var getTrials_gradcpt = function(num_trials_gradcpt_block){
    // array you return with the timeline objects
    var trials = []

    // calculate how many elements of the final_list we need to take off
    // for num_trials_gradcpt_block rounds, it is num_trials_gradcpt_block * 2 - 1 items of the list
    // when we splice off items from the front of the list though, it should be num_trials_gradcpt_block * 2 
    // since we won't use the final transition for anything anyways
    var num_items = num_trials_gradcpt_block * 2

    for (let i = 0; i < num_items - 1; i = i + 2) {
        // get each stimuli
        var img_stim = final_list[i]
        var transition_stim = final_list[i + 1]

        // define correct values for give stimuli
        var img_stim_type = "go"
        var transition_stim_type = "go"
        var img_correct_key = "enter"
        var transition_correct_key = "enter"

        if (img_stim.includes("mountain")){
            img_stim_type = "no-go"
            img_correct_key = null
        }
        if (transition_stim.split('/')[2].split('_')[1].includes("m")){
            transition_stim_type = "no-go"
            transition_correct_key = null
        }

        // add image trials
        var trial_img = {
            type: jsPsychImageKeyboardResponse,
            stimulus: img_stim,
            choices: ['enter'],
            data: {
                stimulus_type: img_stim_type,
                correct_key: img_correct_key,
                trial_number: i,
                game_type: "gradcpt",
                practice: "false",
                cpt_type: "img"
            },
            // fix the step function so that if the transition was correct, it doesn't mean this specific image gets harder
            trial_duration: function(i,adjust_duration=false){
                // this means for every single trial we maintain the level at level_for_all_trials
                if (adjust_duration == false) {
                    curr_trial_duration_level = level_for_all_trials
                    return duration_levels_dict[curr_trial_duration_level]
                } else {
                    if (i == 0) { // this is the first round
                        return duration_levels_dict[curr_trial_duration_level]
                    } else {
                        // change based on last full image, not based on transition
                        prev_correct = jsPsych.data.get().last(2).values()[0].correct;
                        if (prev_correct) {
                            curr_trial_duration_level = curr_trial_duration_level + 1
                            if (curr_trial_duration_level <= max_dur) {
                                return duration_levels_dict[curr_trial_duration_level]
                            } else {
                                curr_trial_duration_level = max_dur
                                return duration_levels_dict[curr_trial_duration_level]
                            }
                        } else {
                            curr_trial_duration_level = curr_trial_duration_level - 1
                            if (curr_trial_duration_level >= min_dur) {
                                return duration_levels_dict[curr_trial_duration_level]
                            } else {
                                curr_trial_duration_level = min_dur
                                return duration_levels_dict[curr_trial_duration_level]
                            }
                        }
                    }
                }
            },
            response_ends_trial:false,
            render_on_canvas: false,
            on_finish: function(data){
                // first check if they got it correct during the previous transition trial
                var prev_correct = false
                if (i != 0) {// if this is the first trial, then there is no previous transition trial
                    prev_correct = jsPsych.data.get().last(2).values()[0].correct
                }
                // Score the response as correct or incorrect.
                if(jsPsych.pluginAPI.compareKeys(data.response, data.correct_key)){
                  data.correct = true;
                } else {
                  if (prev_correct){// if the transition was correct then it seeps onto the image trial
                    // unless its a mountain trial, then if they're wrong in image trial they're wrong
                    if (data.stimulus_type == "no-go") {
                        data.correct = false;
                    } else {
                        data.correct = true;
                    }
                  } else {
                    data.correct = false; 
                  }
                }
                data.curr_level = curr_trial_duration_level
                data.curr_trial_duration = duration_levels_dict[curr_trial_duration_level]
            }
        };

        // add transition trials
        var trial_transition = {
            type: jsPsychImageKeyboardResponse,
            stimulus: transition_stim,
            choices: ['enter'],
            data: {
                stimulus_type: transition_stim_type,
                correct_key: transition_correct_key,
                curr_level: 1,
                curr_trial_duration: duration_levels_dict[1],
                trial_number: i+1,
                game_type: "gradcpt",
                practice: "false",
                cpt_type: "transition"
            },
            trial_duration:duration_levels_dict[1],
            response_ends_trial:false,
            render_on_canvas: false,
            on_finish: function(data){
                // Score the response as correct or incorrect.
                if(jsPsych.pluginAPI.compareKeys(data.response, data.correct_key)){
                  data.correct = true;
                } else {
                  data.correct = false; 
                }
            }
        };

        trials.push(trial_img)
        trials.push(trial_transition)
    }

    // remove the items you used from the final_list array
    final_list.splice(num_items)

    return trials
}

// GET PRACTICE TRIALS FUNCTION
// each "trial round" is the image being shown, and the following transition
// pass in how many trial timeline rounds you want it to generate, and remove those from the final_list
var getTrials_practice_gradcpt = function(num_trials_gradcpt_block){
    // array you return with the timeline objects
    var trials = []

    // calculate how many elements of the final_list we need to take off
    // for num_trials_gradcpt_block rounds, it is num_trials_gradcpt_block * 2 - 1 items of the list
    // when we splice off items from the front of the list though, it should be num_trials_gradcpt_block * 2 
    // since we won't use the final transition for anything anyways
    var num_items = num_trials_gradcpt_block * 2

    for (let i = 0; i < num_items - 1; i = i + 2) {
        // get each stimuli
        var img_stim = final_list[i]
        var transition_stim = final_list[i + 1]

        // define correct values for give stimuli
        var img_stim_type = "go"
        var transition_stim_type = "go"
        var img_correct_key = "enter"
        var transition_correct_key = "enter"

        if (img_stim.includes("mountain")){
            img_stim_type = "no-go"
            img_correct_key = null
        }
        if (transition_stim.split('/')[2].split('_')[1].includes("m")){
            transition_stim_type = "no-go"
            transition_correct_key = null
        }

        // add image trials
        var trial_img = {
            type: jsPsychImageKeyboardResponse,
            stimulus: img_stim,
            choices: ['enter'],
            data: {
                stimulus_type: img_stim_type,
                correct_key: img_correct_key,
                trial_number: i,
                game_type: "gradcpt",
                practice: "true",
                cpt_type: "img"
            },
            prompt:"<div style='text-align: center; margin-top: 20px;'>Press Enter if it is a city.</div>",
            // fix the step function so that if the transition was correct, it doesn't mean this specific image gets harder
            trial_duration: function(i,adjust_duration=false){
                // this means for every single trial we maintain the level at level_for_all_trials
                if (adjust_duration == false) {
                    curr_trial_duration_level = level_for_all_trials
                    return duration_levels_dict[curr_trial_duration_level]
                } else {
                    if (i == 0) { // this is the first round
                        return duration_levels_dict[curr_trial_duration_level]
                    } else {
                        // change based on last full image, not based on transition
                        prev_correct = jsPsych.data.get().last(2).values()[0].correct;
                        if (prev_correct) {
                            curr_trial_duration_level = curr_trial_duration_level + 1
                            if (curr_trial_duration_level <= max_dur) {
                                return duration_levels_dict[curr_trial_duration_level]
                            } else {
                                curr_trial_duration_level = max_dur
                                return duration_levels_dict[curr_trial_duration_level]
                            }
                        } else {
                            curr_trial_duration_level = curr_trial_duration_level - 1
                            if (curr_trial_duration_level >= min_dur) {
                                return duration_levels_dict[curr_trial_duration_level]
                            } else {
                                curr_trial_duration_level = min_dur
                                return duration_levels_dict[curr_trial_duration_level]
                            }
                        }
                    }
                }
            },
            response_ends_trial:false,
            render_on_canvas: false,
            on_finish: function(data){
                // first check if they got it correct during the previous transition trial
                var prev_correct = false
                if (i != 0) {// if this is the first trial, then there is no previous transition trial
                    prev_correct = jsPsych.data.get().last(2).values()[0].correct
                }
                // Score the response as correct or incorrect.
                if(jsPsych.pluginAPI.compareKeys(data.response, data.correct_key)){
                  data.correct = true;
                } else {
                  if (prev_correct){// if the transition was correct then it seeps onto the image trial
                    // unless its a mountain trial, then if they're wrong in image trial they're wrong
                    if (data.stimulus_type == "no-go") {
                        data.correct = false;
                    } else {
                        data.correct = true;
                    }
                  } else {
                    data.correct = false; 
                  }
                }
                data.curr_level = curr_trial_duration_level
                data.curr_trial_duration = duration_levels_dict[curr_trial_duration_level]
            }
        };

        // add transition trials
        var trial_transition = {
            type: jsPsychImageKeyboardResponse,
            stimulus: transition_stim,
            choices: ['enter'],
            prompt: "<div style='text-align: center; margin-top: 20px;'>Press Enter if it is a city.</div>",
            data: {
                stimulus_type: transition_stim_type,
                correct_key: transition_correct_key,
                curr_level: 1,
                curr_trial_duration: duration_levels_dict[1],
                trial_number: i+1,
                game_type: "gradcpt",
                practice: "true",
                cpt_type: "transition"
            },
            trial_duration:duration_levels_dict[1],
            response_ends_trial:false,
            render_on_canvas: false,
            on_finish: function(data){
                // Score the response as correct or incorrect.
                if(jsPsych.pluginAPI.compareKeys(data.response, data.correct_key)){
                  data.correct = true;
                } else {
                  data.correct = false; 
                }
            }
        };
        trials.push(trial_img)
        trials.push(trial_transition)
    }

    // add a feedback trial here
    var cpt_practice_feedback = {
        type: jsPsychHtmlKeyboardResponse,
        trial_duration: 5000,
        response_ends_trial:false,
        stimulus: function(){
            var cpt_practice_trials = jsPsych.data.get().filter({game_type:"gradcpt",practice:"true",cpt_type: "img"}).values();
            var num_cpt_practice_trials = cpt_practice_trials.length
            var accuracy_count = 0
            for (let i = 0; i < num_cpt_practice_trials; i++){
                if(cpt_practice_trials[i].correct){
                    accuracy_count += 1
                }
            }

            var accuracy =  num_cpt_practice_trials > 0 ? (100 * accuracy_count / num_cpt_practice_trials) : 0;
            
            jsPsych.data.get().addToLast({cpt_practice_accuracy: accuracy});// should I do something where if they get a lot wrong they have to do it again? or would this just be exclusion criteria?

            return '<div>You got ' + accuracy + '% correct </p>'
        }
      }
    
    trials.push(cpt_practice_feedback)

    // remove the items you used from the final_list array
    final_list.splice(num_items)

    return trials
}

//////////////////////////////////////////////////////////////////////////////
//// TIMELINE CREATION

// ORDERED LIST OF STIMULI (length: totalTrialNum_gradcpt = practice_trials_gradcpt_num + num_blocks*gradcpt_trials_per_block = max possible number of gradCPT trials in this experiment)
var final_list = random_stimulus_list(totalTrialNum_gradcpt)

// PRACTICE TRIALS
var gradcpt_practice_trials = {
    timeline: getTrials_practice_gradcpt(practice_trials_gradcpt_num)
}

/////////////////////////////////////////////////////
// spatial-recall file
///////////////////////////////////////////////////////////////
////// SET UP GRID DIFFICULTY TO BE MAX_TILE_DURATION & CREATE num_trials TRIALS
// this function sets up the timing of each trial. 
// IF CHANGE_DIFFICULTY = TRUE: It will start with the max duration for the first group of 5. Then for every subsequent group it will sample from prev_group - 100 +/- 50.
// IF CHANGE_DIFFICULTY = FALSE (default): it will give every trial the given max_tile_duration
function getGridParams(num_trials,max_tile_duration,change_difficulty=false) {
  // the number of trials i want to group together
  var num_trial_per_group = 5;
  // the difference in mean time I want per group
  var mean_time_diff = 100;
  // Initialize an array to hold the duration of each trial
  var trialDurations = [];
  // Calculate the number of full groups of 5 and the remainder
  var fullGroups = Math.floor(num_trials / num_trial_per_group);
  var remainder = num_trials % num_trial_per_group;
  // Initialize the current duration to the max duration
  var currentDuration = max_tile_duration;

  if (change_difficulty) {
    // Process full groups
    for (let i = 0; i < fullGroups; i++) {
      // make first group anywhere in the range of (the max time - 50)
      if (i == 0) {
        for (let j = 0; j < num_trial_per_group; j++) {
          trialDurations.push(Math.max(0, currentDuration - Math.floor(Math.random() * (mean_time_diff / 2))))
        }
        currentDuration = currentDuration - mean_time_diff
        continue;
      }
      // make each following groups anywhere in +50 or -50 of the previous max time - 100
      let min = 0
      if (((currentDuration - (mean_time_diff / 2)) >= 0)) {
        min = currentDuration - (mean_time_diff / 2)
      }
      // adding the +1 makes it inclusive
      for (let j = 0; j < num_trial_per_group; j++) {
        trialDurations.push(Math.floor(Math.random() * (mean_time_diff + 1) + min))
      }
      // update the new current duration (mean duration) for the next group
      currentDuration = currentDuration - mean_time_diff
    }
    // Process any remaining trials and give them all the final value
    let min = 0
    if (((currentDuration - (mean_time_diff / 2)) >= 0)) {
    min = currentDuration - (mean_time_diff / 2)
    }
    for (let i = 0; i < remainder; i++) {
      trialDurations.push(Math.floor(Math.random() * (mean_time_diff + 1) + min));
    }
  } else {
    for (i=0;i < num_trials;i++) {
      trialDurations.push(max_tile_duration)
    }
  }

  // go through the trial durations and return the timeline vals
  let timeline_full_vals = []
  trialDurations.forEach((item, _) => {
    timeline_full_vals.push({
        sequence: jsPsych.randomization.sampleWithoutReplacement([...Array(16).keys()], digits_to_mem),
        tile_duration: item
    });
  });
  return timeline_full_vals
}

// PRACTICE SESSION
var sr_recall_forwards_practice = {
  timeline: [
    {
      type: jsPsychScreenCheck,
      min_width: 258,
      min_height: 364
    },
    {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<p style="font-size: 48px;">+</p>',
      choices: 'NO_KEYS',
      trial_duration: 400,
    },
    {
      type: jsPsychSpatialRecall,
      grid_size: grid_size_constant,
      sequence: jsPsych.timelineVariable('sequence'),
      tile_duration: jsPsych.timelineVariable('tile_duration'),
      backwards: false,
      on_finish: function(data){
        data.practice = "true"
        data.game_type = "spatial_recall"
      }
    },
    {
      type: jsPsychHtmlKeyboardResponse,
      trial_duration: 1000,
      stimulus: function(){
        var last_trial_correct = jsPsych.data.get().last(1).values()[0].score_an;
        if(last_trial_correct){
          return "<p>Correct!</p>"; // the parameter value has to be returned from the function
        } else {
          return "<p>Incorrect! Please try to focus on the order in which the squares appear.</p>"; // the parameter value has to be returned from the function
        }
      }
    }
  ],
  timeline_variables: getGridParams(sr_practice_trial_num,consistent_tile_duration,false)
}

// MAIN EXPERIMENT GET BLOCK TRIALS FUNCTION
function sr_getBlock() {
  var timeline_sr_block = []

  var screenCheck={
    type: jsPsychScreenCheck,
    min_width: 258,
    min_height: 364
  }

  var response_key = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: '<p style="font-size: 48px;">+</p>',
    choices: 'NO_KEYS',
    trial_duration: 400,
  }

  var recall_sr = {
    type: jsPsychSpatialRecall,
    grid_size: grid_size_constant,
    sequence: jsPsych.randomization.sampleWithoutReplacement([...Array(16).keys()], digits_to_mem),
    tile_duration: consistent_tile_duration,
    backwards: false,
    on_finish: function(data){
      data.practice = "false"
      data.game_type = "spatial_recall"
    }
  }

  for (i=0; i < sr_trials_per_block; i++){
    timeline_sr_block.push(screenCheck,response_key,recall_sr)
  }

  return timeline_sr_block
}
//////////////////////
// INSTRUCTIONS file
// WELCOME TO EXPERIMENT
var welcome_practice_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>Welcome to this experiment! In this experiment, you will be doing two tasks. Before we begin the actual experiment, let\'s do some practice trials.</p>"
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next'
  }

// #TODO CONSENT FORM

// SPATIAL RECALL TASK INSTRUCTIONS (before each SR block)
var sr_task_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>Welcome to the spatial recall game! Click next for the instructions.</p>",
      "<p>In this game you will see a grid of squares that will flash blue one at a time.</p><p>Your goal is to remember the order in which the squares flashed blue.</p><p>At the end of each trial, press the tiles that flashed in the <b>same order</b> as they were presented to you.</p>",
      `<p>Do your best to memorize the order, but do not write them down<br>or use any other external tool to help you remember.</p><p>If you make a mistake, click the "Clear" button to erase your entries.</p><p>When you're ready, click "Next" to get started.</p>`
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next'
  }

  // TRANSITION BETWEEN GAMES IN PRACTICE SESSION
  var practice_transition = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: '<p> Great work! You will now have practice for the next game. Press any key to continue. </p>',
    choices: "ALL_KEYS"
    //trial_duration: 1200,
  }

// GRADCPT TASK INSTRUCTIONS (before each gradcpt block)
var cpt_task_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>Welcome to the gradual onset game! Click next for the instructions.</p>",
      "<p>In this task, an image will appear in the center of the screen.</p><p>\
      If the image is a <strong>city</strong> press enter on the keyboard as fast as you can.</p><p>\
      If the image is a <strong>mountain</strong>, do not press a key.</p>\
      <div style='width: 700px;'><div style='float: left;'><img src='./img900_esterman/city_1.jpg'></img>\
      <p class='small'><strong>Press the enter key</strong></p></div>\
      <div style='float: right;'><img src='./img900_esterman/mountain_1.jpg'></img>\
      <p class='small'><strong>Do not press a key</strong></p></div>\
      </div>",
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next'
  }

// MAIN EXPERIMENT INSTRUCTIONS + BDM
var main_exp_BDM_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>We will now go into instructions for the main experiment.</p>",
      "<p>You will be given points based on your accuracy in each trial, which will be converted to a monetary bonus at the end of the experiment. \
      You will not be shown how many points you have until the end.</p><p>",
      "<p>In this experiment, you will be switching between the two games you practiced earlier. You will occasionally be asked how many points \
      (on a scale of 1 to 100)  you are willing to give away in order to switch to the other game</p>",
      "<p>Think of this like an auction. We will also randomly generate a value from 1 to 100 each time you pick a value, and if your selection is \
      larger <strong>you will get to switch games</strong> and <strong>you will only pay the number that we randomly generated </strong>\
      (even if your value was significantly higher). If the value you offered is <strong>lower</strong> than our randomly generated value, you will continue playing \
      your current game. Because of this,<strong> it is to your benefit to be honest in how much you are willing to pay</strong>.</p>",
      "<p>You will now be asked to answer a few questions about this, so feel free to re-read the instructions before you click Next </p>"
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next'
  }

// BDM QUIZ
var BDM_quiz = {
    type: jsPsychSurveyMultiChoice,
    questions: [
      {
        prompt: "To get the best result when it comes to switching, I should:", 
        name: 'BDM_should', 
        options: ['always give a higher number of points than I would really want to trade to switch', 'always give a lower number of points than I would really want to trade to switch', 'always be honest about exactly how many points I would be willing to switch'], 
        required: true
      }
    ],
  };

var final_exp_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>Great! You are now ready to begin.</p>",
      "<p>As a reminder, in this experiment you will start off with playing one of the two games you previously practiced. You will be given points each time you are correct (although you will not see them). You will also occasionally be asked how many points you would trade to switch to the other game. \
      If your answer is higher than our randomly generated one, you will be switched! \
      If not, you will stay on this game</p>",
      "<p>When you're ready, press Next to begin</p>",
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next'
}

// MAIN HTML file (experiment-looping)

// important variables to customize
var dollars_per_correct_bonus = 0.30

// INITIALIZE TIMELINE
var timeline = [];

// PRELOADS
timeline.push(preload_auto, preload_manual)

// INTRUCTIONS AND PRACTICE SESSION
timeline.push(welcome_practice_instructions,sr_task_instructions,sr_recall_forwards_practice,practice_transition,cpt_task_instructions,gradcpt_practice_trials)

// MAIN EXPERIMENT INSTRUCTIONS
timeline.push(main_exp_BDM_instructions, BDM_quiz, final_exp_instructions)

///////////////////////////////////////////////////////////
// MAIN EXPERIMENT
var generated_value = Math.floor(Math.random() * 101);
var currentTask = "spatial_recall" //(50% chance of either task being the first block) // other option is "gradcpt"
if (Math.random() < 0.5) {
    currentTask = "gradcpt"
}
var curr_block = 0
var nextSwitch = false // update this in the on_finish of the switch_offer_screen

// SWITCH OFFER SCREEN
var switch_offer_screen = {
    type: jsPsychHtmlSliderResponse,
    stimulus: `<div style="width:500px;">
        <p>How many points do you want to trade to switch games?</p>
        </div>`,
    require_movement: true,
    labels: ['0 points', '50 points', '100 points'],
    on_start: function(switch_offer_screen) {
        generated_value =  Math.floor(Math.random() * 101);
    },
    on_finish: function(data){
        var trade_value = jsPsych.data.get().last(1).values()[0].response
        data.generated_BDM_value = generated_value
        data.blocks_completed = curr_block
        data.prevBlockType = currentTask

        if (trade_value >= generated_value) {
            nextSwitch = true

            if (currentTask == "spatial_recall") {
                currentTask = "gradcpt"
            } else if (currentTask == "gradcpt") {
                currentTask = "spatial_recall"
            }
        } else {
            nextSwitch = false
        }

        data.switch_next_block = nextSwitch
    }
}

// final debrief 
var calculate_bonus = function(){
    // get grad cpt trials which are NOT practice and which are img trials (these have updated correctness info)
    // can try doing .select('correct')
    var gradcpt_img_trials = jsPsych.data.get().filter({game_type:"gradcpt",practice:"false",cpt_type: "img"}).values();

    // get sr trials which are NOT practice
    // can try doing .select("score_an")
    var sr_trials = jsPsych.data.get().filter({game_type:"spatial_recall",practice:"false"}).values();

    // get their accuracies
    var accuracy_count = 0
    var sr_len = sr_trials.length
    var gradcpt_len = gradcpt_img_trials.length
    for (let i = 0; i < sr_len;i++) {
        accuracy_count = accuracy_count + sr_trials[i].score_an
    }
    for (let i = 0; i < gradcpt_len; i++){
        if(gradcpt_img_trials[i].correct){
            accuracy_count += 1
        }
    }

    // for now let's say 35 cents per correct answer
    var total_trials = sr_len + gradcpt_len
    var accuracy_calc = total_trials > 0 ? (accuracy_count / total_trials) : 0;    
    var final_bonus = (accuracy_count * dollars_per_correct_bonus).toFixed(2)


    // add the final accuracy and bonus to data
    jsPsych.data.get().addToLast({bonus: final_bonus,overall_accuracy: accuracy_calc});

    return final_bonus
}

var overall_debrief = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: 
      `<p>Thanks for participating! This experiment seeked to understand how cognitive fatigue, \
      effort, errors, and task switching interact. Your final bonus (based purely on how correct you \
    were) is <strong>insert</strong>. The experiment is over now, press any button to continue</p>`,
    on_start: function(overall_debrief) {
        var bonus = calculate_bonus()

        overall_debrief.stimulus = "<p>Thanks for participating! This experiment seeked to understand how cognitive fatigue, \
            effort, errors, and task switching interact. Your final bonus (based purely on how correct you \
          were) is $<strong>" + bonus + " dollars </strong>. The experiment is over now, press any button to continue</p>"
    }
}

// task switch or stay trials
var switchingGamesNotification = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: 'You will now switch to a new game',
    choices: 'NO_KEYS',  // No responses allowed
    trial_duration: 1000,
    on_start: function(switchingGamesNotification) {
        if (curr_block >= num_blocks){
            switchingGamesNotification.stimulus = "Great work! We will now debrief you."
        } else if (nextSwitch == false) {
            switchingGamesNotification.stimulus = "You will now stay in the same game."
        }
    }
};

var gradcpt_block_trials = {
    timeline: getTrials_gradcpt(gradcpt_trials_per_block)
}
var sr_block_trials = {
    timeline: sr_getBlock()
}
var full_gradcpt_block = {
    timeline: [gradcpt_block_trials]
}
var full_sr_block = {
    timeline: [sr_block_trials]
}

// FIRST BLOCK ADD MANUALLY
if (curr_block == 0 && currentTask == "spatial_recall") {
    timeline.push(full_sr_block,switch_offer_screen,switchingGamesNotification)
    curr_block = curr_block + 1
} else {
    timeline.push(full_gradcpt_block,switch_offer_screen,switchingGamesNotification)
    curr_block = curr_block + 1
}

// IF NODES FOR REST OF THE BLOCKS
var if_cpt_node = {
    timeline: [full_gradcpt_block],
    conditional_function: function(){// if return true, this timeline gets run if not it gets skipped
        // currentTask will get updated in the switch_offer_screen on finish, so don't need to worry about switch or no switch here
        if (curr_block == num_blocks || currentTask == "spatial_recall"){
            return false
        } else {
            curr_block = curr_block + 1
            return true
        } 
    }
}
var if_sr_node = {
    timeline: [full_sr_block],
    conditional_function: function(){// if return true, this timeline gets run if not it gets skipped
        // currentTask will get updated in the switch_offer_screen on finish, so don't need to worry about switch or no switch here
        if (curr_block == num_blocks || currentTask == "gradcpt"){
            return false
        } else {
            curr_block = curr_block + 1
            return true
        }
    }
}

var if_debrief_node = {
    timeline: [overall_debrief],
    conditional_function: function() {
        if (curr_block == num_blocks){
            return true
        } else {
            return false
        }
    }
}

// add the main experiment
var main_loop = {
    timeline: [if_cpt_node,if_sr_node,switch_offer_screen,switchingGamesNotification,if_debrief_node],
    loop_function: function(data){
        if (curr_block >= num_blocks) {
            return false
        } else {
            return true
        }
    }
}
timeline.push(main_loop)

// RUN THE EXPERIMENT
jsPsych.run(timeline);