// important experiment variables
// SR EXPERIMENT SET UP VARIABLES
var sr_trials_per_block = 8//was 8
var sr_practice_trial_num = 6//was 6
var consistent_tile_duration = 325
var grid_size_constant = 4
var digits_to_mem = 4
// CPT EXPERIMENT SET UP VARIABLES
// max number of totalTrialNum_gradcpt = practice trials + num_blocks * gradcpt_trials_per_block
var practice_trials_gradcpt_num = 30
var num_blocks = 8
var gradcpt_trials_per_block = 40
// we will generate a stimuli list for the MAX amount of trials the gradcpt might have (depending on switches, some of these will not be used)
var totalTrialNum_gradcpt = practice_trials_gradcpt_num + num_blocks*gradcpt_trials_per_block
var level_for_all_trials = 1 // this is all that matters in this version since adjust_duration below is false
var curr_trial_duration_level = 1
// experiment_looping file
// important variables to customize
var dollars_per_correct_bonus = 0.01
var cpt_ran = false
var curr_block = 0

/////////////////////////////
// Initialize jsPsych.
var jsPsych = initJsPsych({
    show_progress_bar: true,
    auto_update_progress_bar: false,
    on_finish: function() {
      // Add interactions to the data variable
      // var interaction_data = jsPsych.data.getInteractionData();
      // jsPsych.data.get().addToLast({interactions: interaction_data.json()});
      // Display jsPsych data in viewport.
      jsPsych.data.displayData();
    }
  });
  
// spatial recall file
///////////////////////////////////////////////////////////////
////// SET UP GRID DIFFICULTY TO BE MAX_TILE_DURATION & CREATE num_trials TRIALS
// this function sets up the timing of each trial. 
// IF CHANGE_DIFFICULTY = TRUE: It will start with the max duration for the first group of 5. Then for every subsequent group it will sample from prev_group - 100 +/- 50.
// IF CHANGE_DIFFICULTY = FALSE (default): it will give every trial the given max_tile_duration
function getGridParams(num_trials,max_tile_duration,change_difficulty=false) {
  // the number of trials i want to group together
  var num_trial_per_group = 5;
  // the difference in mean time I want per group
  var mean_time_diff = 100;
  // Initialize an array to hold the duration of each trial
  var trialDurations = [];
  // Calculate the number of full groups of 5 and the remainder
  var fullGroups = Math.floor(num_trials / num_trial_per_group);
  var remainder = num_trials % num_trial_per_group;
  // Initialize the current duration to the max duration
  var currentDuration = max_tile_duration;

  if (change_difficulty) {
    // Process full groups
    for (let i = 0; i < fullGroups; i++) {
      // make first group anywhere in the range of (the max time - 50)
      if (i == 0) {
        for (let j = 0; j < num_trial_per_group; j++) {
          trialDurations.push(Math.max(0, currentDuration - Math.floor(Math.random() * (mean_time_diff / 2))))
        }
        currentDuration = currentDuration - mean_time_diff
        continue;
      }
      // make each following groups anywhere in +50 or -50 of the previous max time - 100
      let min = 0
      if (((currentDuration - (mean_time_diff / 2)) >= 0)) {
        min = currentDuration - (mean_time_diff / 2)
      }
      // adding the +1 makes it inclusive
      for (let j = 0; j < num_trial_per_group; j++) {
        trialDurations.push(Math.floor(Math.random() * (mean_time_diff + 1) + min))
      }
      // update the new current duration (mean duration) for the next group
      currentDuration = currentDuration - mean_time_diff
    }
    // Process any remaining trials and give them all the final value
    let min = 0
    if (((currentDuration - (mean_time_diff / 2)) >= 0)) {
    min = currentDuration - (mean_time_diff / 2)
    }
    for (let i = 0; i < remainder; i++) {
      trialDurations.push(Math.floor(Math.random() * (mean_time_diff + 1) + min));
    }
  } else {
    for (i=0;i < num_trials;i++) {
      trialDurations.push(max_tile_duration)
    }
  }

  // go through the trial durations and return the timeline vals
  let timeline_full_vals = []
  trialDurations.forEach((item, _) => {
    timeline_full_vals.push({
        sequence: jsPsych.randomization.sampleWithoutReplacement([...Array(16).keys()], digits_to_mem),
        tile_duration: item
    });
  });
  return timeline_full_vals
}

// PRACTICE SESSION
var sr_practice_prop_added = 1/sr_practice_trial_num
var sr_recall_forwards_practice = {
  timeline: [
    {
      type: jsPsychScreenCheck,
      min_width: 258,
      min_height: 364
    },
    {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<p style="font-size: 48px;">+</p>',
      choices: 'NO_KEYS',
      trial_duration: 400,
    },
    {
      type: jsPsychSpatialRecall,
      grid_size: grid_size_constant,
      sequence: jsPsych.timelineVariable('sequence'),
      tile_duration: jsPsych.timelineVariable('tile_duration'),
      backwards: false,
      on_finish: function(data){
        data.practice = "true"
        data.game_type = "spatial_recall"
      }
    },
    {
      type: jsPsychHtmlKeyboardResponse,
      trial_duration: 1000,
      stimulus: function(){
        var last_trial_correct = jsPsych.data.get().last(1).values()[0].score_an;
        if(last_trial_correct){
          return "<p>Correct!</p>"; // the parameter value has to be returned from the function
        } else {
          return "<p>Incorrect! Please try to focus on the order in which the squares appear.</p>"; // the parameter value has to be returned from the function
        }
      },
      on_start: function(){
        var update_to = jsPsych.getProgressBarCompleted() + sr_practice_prop_added
        jsPsych.setProgressBar(update_to);
      }
    }
  ],
  timeline_variables: getGridParams(sr_practice_trial_num,consistent_tile_duration,false)
}

// MAIN EXPERIMENT GET BLOCK TRIALS FUNCTION
function sr_getBlock() {
  var timeline_sr_block = []
  var proportion_per_trial = 1 / sr_trials_per_block

  for (i=0; i < sr_trials_per_block; i++){
    var screenCheck={
      type: jsPsychScreenCheck,
      min_width: 258,
      min_height: 364
    }
  
    var response_key = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<p style="font-size: 48px;">+</p>',
      choices: 'NO_KEYS',
      trial_duration: 400,
    }
  
    var recall_sr = {
      type: jsPsychSpatialRecall,
      grid_size: grid_size_constant,
      sequence: jsPsych.randomization.sampleWithoutReplacement([...Array(16).keys()], digits_to_mem),
      tile_duration: consistent_tile_duration,
      backwards: false,
      on_start: function(recall_sr) {
        recall_sr.sequence = jsPsych.randomization.sampleWithoutReplacement([...Array(16).keys()], digits_to_mem)
        console.log(recall_sr.sequence)
      },
      on_finish: function(data){
        data.practice = "false"
        data.game_type = "spatial_recall"

        var progressbar_update = jsPsych.getProgressBarCompleted() + proportion_per_trial
        jsPsych.setProgressBar(progressbar_update);
      }
    }

    timeline_sr_block.push(screenCheck,response_key,recall_sr)
  }

  return timeline_sr_block
}
///////////////////////////////////////////
// gradcpt file
// STIMULI AND DURATION
var all_stim = ["city_1.jpg","city_2.jpg","city_3.jpg","city_4.jpg", "city_5.jpg","city_6.jpg","mountain_1.jpg",
"c1_c2.gif","c1_c3.gif","c1_c4.gif","c1_c5.gif","c1_c6.gif","c1_m1.gif","c2_c1.gif","c2_c3.gif","c2_c4.gif","c2_c5.gif","c2_c6.gif",
"c2_m1.gif","c3_c1.gif","c3_c2.gif","c3_c4.gif","c3_c5.gif","c3_c6.gif",
"c3_m1.gif","c4_c1.gif","c4_c2.gif","c4_c3.gif","c4_c5.gif","c4_c6.gif",
"c4_m1.gif","c5_c1.gif","c5_c2.gif","c5_c3.gif","c5_c4.gif","c5_c6.gif",
"c5_m1.gif","c6_c1.gif","c6_c2.gif","c6_c3.gif","c6_c4.gif","c6_c5.gif",
"c6_m1.gif","m1_c1.gif","m1_c2.gif","m1_c3.gif","m1_c4.gif","m1_c5.gif",
"white_1.jpg","c1_white1.gif", "c2_white1.gif","c3_white1.gif","c4_white1.gif",
"c5_white1.gif","c6_white1.gif","m1_white1.gif","white1_c1.gif","white1_c2.gif",
"white1_c3.gif","white1_c4.gif","white1_c5.gif","white1_c6.gif","white1_m1.gif"]

let duration_levels_dict = {
    1: 700,2: 680,3: 660,4: 640,5: 620,6: 600,7: 580,8: 560,9: 540,10: 520,11: 500,
}

let stim_dict = {
    '1': 'city_1.jpg','2': 'city_2.jpg','3': 'city_3.jpg','4': 'city_4.jpg','5': 'city_5.jpg','6': 'city_6.jpg',
    '0': 'mountain_1.jpg', '1-0': 'c1_m1.gif','1-2': 'c1_c2.gif','1-3': 'c1_c3.gif','1-4': 'c1_c4.gif','1-5': 'c1_c5.gif',
    '1-6': 'c1_c6.gif','2-0': 'c2_m1.gif','2-1': 'c2_c1.gif','2-3': 'c2_c3.gif','2-4': 'c2_c4.gif','2-5': 'c2_c5.gif',
    '2-6': 'c2_c6.gif','3-0': 'c3_m1.gif','3-1': 'c3_c1.gif','3-2': 'c3_c2.gif','3-4': 'c3_c4.gif',
    '3-5': 'c3_c5.gif','3-6': 'c3_c6.gif','4-0': 'c4_m1.gif','4-1': 'c4_c1.gif','4-2': 'c4_c2.gif',
    '4-3': 'c4_c3.gif', '4-5': 'c4_c5.gif','4-6': 'c4_c6.gif','5-0': 'c5_m1.gif','5-1': 'c5_c1.gif',
    '5-2': 'c5_c2.gif','5-3': 'c5_c3.gif','5-4': 'c5_c4.gif','5-6': 'c5_c6.gif', '6-0': 'c6_m1.gif',
    '6-1': 'c6_c1.gif','6-2': 'c6_c2.gif', '6-3': 'c6_c3.gif','6-4': 'c6_c4.gif','6-5': 'c6_c5.gif',
    '0-1': 'm1_c1.gif','0-2': 'm1_c2.gif','0-3': 'm1_c3.gif','0-4': 'm1_c4.gif','0-5': 'm1_c5.gif',
    '0-6': 'm1_c6.gif','-1':"white_1.jpg",'-1-1':"white1_c1.gif",'-1-2':"white1_c2.gif",
    '-1-3':"white1_c3.gif",'-1-4':"white1_c4.gif",'-1-5':"white1_c5.gif",'-1-6':"white1_c6.gif",'-1-0':"white1_m1.gif",
    '1--1':"c1_white1.gif", '2--1':"c2_white1.gif",'3--1':"c3_white1.gif",'4--1':"c4_white1.gif",'5--1':"c5_white1.gif",
    '6--1':"c6_white1.gif",'0--1':"m1_white1.gif"
};

// UPDATED TO ADD THE TRANSITION FROM WHITE AND THE TRANSITION TO WHITE
// num_trials = practice_trials_gradcpt_num + gradcpt_trials_per_block * num_blocks
// each trial will be white to first img, transiton from first to next img, ....., transition to last, 
// last img, transition from last img to white
var random_stimulus_list = function(num_trials) {
    var prev_trial_index = -1
    let key_stim_list = []
    let final_stim_list = []
    var randomNumber = 0

    // do the practice trials
    var num_trials = practice_trials_gradcpt_num
    prev_trial_index = -1
    for (let i =0; i < num_trials;i++){
        randomNumber = Math.floor(Math.random() * 10); // Generates a number between 0 and 9
        // this means this is the first trial
        if (prev_trial_index == -1){
            if (randomNumber == 0) {
                // starts with mountain
                // push transition from white to mountain
                key_stim_list.push('-1-'+randomNumber.toString()) // starts with transition white to mountain

                // push mountain
                key_stim_list.push(randomNumber.toString()) // starts with mountain
            } else {
                // starts with a city
                randomNumber = Math.floor(Math.random() * 6) + 1

                // push transition from white to city
                key_stim_list.push('-1-'+randomNumber.toString()) // starts with transition white to city
                // push city
                key_stim_list.push(randomNumber.toString())
            }
            prev_trial_index = randomNumber
            // skip to next trial
            continue
        }

        // this part will only get activated if it is not the first trial
        // adds transition from prev trial index and then a new img
        if (randomNumber == 0 && prev_trial_index != 0) {
            key_stim_list.push(prev_trial_index + '-' + randomNumber) // add transition to this image
            key_stim_list.push(randomNumber.toString()) // add this image
        } else {
            if (prev_trial_index == 0) { // if the prior trial was 0 and we get 0 again, we have to give it a num 1 to 6 instead
                randomNumber = Math.floor(Math.random() * 6) + 1 
            } else {
                randomNumber = Math.floor(Math.random() * 5) + 1 
                if (randomNumber >= prev_trial_index) { // random number is 1-6 now (but will not be = to prev trial)
                    randomNumber++;
                }
            }
            key_stim_list.push(prev_trial_index + "-" + randomNumber) // transition to this image
            key_stim_list.push(randomNumber.toString()) // number between 1 and 6 (excluding prev trial), add this image
        }
        prev_trial_index = randomNumber

        // this part will only get activated if it is the last trial
        // after adding the last trial, add a transition from img to white
        if (i == (num_trials - 1)){
            key_stim_list.push(prev_trial_index.toString() + '--1')// transition from img to white
        }
    }

    // do the blocks, same as practice but do it num_blocks times
    for (j = 0; j < num_blocks; j++){
        num_trials = gradcpt_trials_per_block
        prev_trial_index = -1

        for (let i =0; i < num_trials;i++){
            randomNumber = Math.floor(Math.random() * 10); // Generates a number between 0 and 9
            // this means this is the first trial
            if (prev_trial_index == -1){
                if (randomNumber == 0) {
                    // starts with mountain
                    // push transition from white to mountain
                    key_stim_list.push('-1-'+randomNumber.toString()) // starts with transition white to mountain
    
                    // push mountain
                    key_stim_list.push(randomNumber.toString()) // starts with mountain
                } else {
                    // starts with a city
                    randomNumber = Math.floor(Math.random() * 6) + 1
    
                    // push transition from white to city
                    key_stim_list.push('-1-'+randomNumber.toString()) // starts with transition white to city
                    // push city
                    key_stim_list.push(randomNumber.toString())
                }
                prev_trial_index = randomNumber
                // skip to next trial
                continue
            }
    
            // this part will only get activated if it is not the first trial
            // adds transition from prev trial index and then a new img
            if (randomNumber == 0 && prev_trial_index != 0) {
                key_stim_list.push(prev_trial_index + '-' + randomNumber) // add transition to this image
                key_stim_list.push(randomNumber.toString()) // add this image
            } else {
                if (prev_trial_index == 0) { // if the prior trial was 0 and we get 0 again, we have to give it a num 1 to 6 instead
                    randomNumber = Math.floor(Math.random() * 6) + 1 
                } else {
                    randomNumber = Math.floor(Math.random() * 5) + 1 
                    if (randomNumber >= prev_trial_index) { // random number is 1-6 now (but will not be = to prev trial)
                        randomNumber++;
                    }
                }
                key_stim_list.push(prev_trial_index + "-" + randomNumber) // transition to this image
                key_stim_list.push(randomNumber.toString()) // number between 1 and 6 (excluding prev trial), add this image
            }
            prev_trial_index = randomNumber
    
            // this part will only get activated if it is the last trial
            // after adding the last trial, add a transition from img to white
            if (i == (num_trials - 1)){
                key_stim_list.push(prev_trial_index.toString() + '--1')// transition from img to white
            }
        }
    }

    // transform the keys into image files
    for (const key of key_stim_list) {
        final_stim_list.push("./img900_esterman_w_big/" + stim_dict[key])
    }

    return final_stim_list;
};

// PRELOADING
var preload_stim = []
var path_to_img = "./img900_esterman_w_big/"
for (let i = 0; i < all_stim.length; i++) {
    preload_stim.push(path_to_img + all_stim[i]);
}
var preload_auto = {
    type: jsPsychPreload,
    show_detailed_errors: true,
    auto_preload: true,
    message: 'Please wait while the experiment loads. This may take a few minutes.',
};
var preload_manual = {
    type: jsPsychPreload,
    show_detailed_errors: true,
    images: preload_stim,
    message: 'Please wait while the experiment loads. This may take a few minutes.',
};
var preload_manual_instr = {
    type: jsPsychPreload,
    show_detailed_errors: true,
    images: [path_to_img + 'mountain_1.jpg',path_to_img + 'city_1.jpg'],
    message: 'Please wait while the experiment loads. This may take a few minutes.',
};

// UPDATED GET TRIALS FUNCTION
// each trial round is the transition and then the following image
// it ends with an extra transition from img to white
// pass in how many trial timeline rounds you want it to generate, and remove those from the final_list
var getTrials_gradcpt = function(num_trials){
    // array you return with the timeline objects
    var trials = []

    var proportion_per_trial = 1 / num_trials

    // take of num_trials from final_list
    var num_items = num_trials * 2

    var preload_stim_block = final_list.slice(0,num_items+1)
    preload_stim_block.push(path_to_img + 'mountain_1.jpg',path_to_img + 'city_1.jpg')
    var preload_manual_block = {
      type: jsPsychPreload,
      show_detailed_errors: true,
      images: preload_stim_block,
      message: 'Please wait while the game loads.',
      on_finish: function(){
        console.log("done!")
      }
    };
    trials.push(preload_manual_block)

    // add a transition then image for each trial
    for (let i = 0; i < num_items; i++){// evens are transitions odds are images
        var stim = final_list[i]
        var stim_type = "go"
        var correct_key = " "

        var trial_type = i % 2 == 0 ? 'transition' : 'img'

        if (trial_type == 'transition') { // that means adding a transition trial
            if (stim.split('/')[2].split('_')[1].includes("m")){
                stim_type = "no-go"
                correct_key = null
            }

            // add transition trials
            var trial_transition = {
                type: jsPsychImageKeyboardResponse,
                stimulus: stim,
                choices: [' '],
                data: {
                    stimulus_type: stim_type,
                    correct_key: correct_key,
                    curr_level: 1,
                    curr_trial_duration: duration_levels_dict[1],
                    trial_number: i / 2,
                    game_type: "gradcpt",
                    practice: "false",
                    cpt_type: "transition"
                },
                trial_duration:duration_levels_dict[1],
                response_ends_trial:false,
                render_on_canvas: false,
                on_finish: function(data){
                    // Score the response as correct or incorrect.
                    if(jsPsych.pluginAPI.compareKeys(data.response, data.correct_key)){
                        data.correct = true;
                    } else {
                        console.log("key was pressed, incorrect")
                        data.correct = false; 
                    }
                }
            };
            trials.push(trial_transition)
            continue
        } else { // that means adding an imaage trial
            if (stim.includes("mountain")){
                stim_type = "no-go"
                correct_key = null
            }
            // add image trials
            var trial_img = {
                type: jsPsychImageKeyboardResponse,
                stimulus: stim,
                choices: [' '],
                data: {
                    stimulus_type: stim_type,
                    correct_key: correct_key,
                    trial_number: i / 2,
                    curr_trial_duration: duration_levels_dict[level_for_all_trials],
                    game_type: "gradcpt",
                    practice: "false",
                    cpt_type: "img"
                },
                // fix the step function so that if the transition was correct, it doesn't mean this specific image gets harder
                trial_duration: duration_levels_dict[level_for_all_trials],
                response_ends_trial:false,
                render_on_canvas: false,
                on_finish: function(data){
                    // first check if they got it correct during the previous transition trial
                    var prev_correct = jsPsych.data.get().last(2).values()[0].correct
                    
                    // Score the response as correct or incorrect.
                    if(jsPsych.pluginAPI.compareKeys(data.response, data.correct_key)){
                        data.correct = true;
                        // if it was a mountain, then being incorrect during the transition is enough to be incorrect now 
                        if (data.stimulus_type == "no-go"){
                            data.correct = prev_correct
                        }
                    } else {
                        if (prev_correct){// if the transition was correct then it seeps onto the image trial
                            // unless its a mountain trial, then if they're wrong in image trial they're wrong
                            if (data.stimulus_type == "no-go") {
                                data.correct = false;
                            } else {
                                data.correct = true;
                            }
                        } else {
                            data.correct = false; 
                        }
                    }
                    data.curr_level = curr_trial_duration_level
                    data.curr_trial_duration = duration_levels_dict[curr_trial_duration_level]

                    var progressbar_update = jsPsych.getProgressBarCompleted() + proportion_per_trial
                    jsPsych.setProgressBar(progressbar_update);
                }
            };
            trials.push(trial_img)
            continue
        }
    }

    // add final transition from prev image to white
    var trial_transition = {
        type: jsPsychImageKeyboardResponse,
        stimulus: final_list[num_items],
        choices: [' '],
        data: {
            stimulus_type: 'filler',
            correct_key: ' ',
            curr_level: 1,
            curr_trial_duration: duration_levels_dict[1],
            trial_number: i / 2,
            game_type: "gradcpt",
            practice: "false",
            cpt_type: "transition"
        },
        prompt:"<div style='text-align: center; margin-top: 20px;'>Ending now.</div>",
        trial_duration:duration_levels_dict[1],
        response_ends_trial:false,
        render_on_canvas: false,
    };
    trials.push(trial_transition)

    // remove the items you used from the final_list array
    final_list.splice(0,num_items + 1)

    return trials
}

// GET PRACTICE TRIALS FUNCTION
// each "trial round" is the image being shown, and the following transition
// pass in how many trial timeline rounds you want it to generate, and remove those from the final_list
var getTrials_practice_gradcpt = function(num_trials){
    // array you return with the timeline objects
    var trials = []

    var proportion_to_update = 1/num_trials

    // take of num_trials from final_list
    var num_items = num_trials * 2
    var preload_stim_block = final_list.slice(0,num_items+1)
    preload_stim_block.push(path_to_img + 'mountain_1.jpg',path_to_img + 'city_1.jpg')
    var preload_manual_block = {
      type: jsPsychPreload,
      show_detailed_errors: true,
      images: preload_stim_block,
      message: 'Please wait while the game loads.',
      on_finish: function(){
        console.log("done!")
      }
    };
    trials.push(preload_manual_block)

    // add a transition then image for each trial
    for (let i = 0; i < num_items; i++){// evens are transitions odds are images
        var stim = final_list[i]
        var stim_type = "go"
        var correct_key = " "//space key

        var trial_type = i % 2 == 0 ? 'transition' : 'img'

        if (trial_type == 'transition') { // that means adding a transition trial
            if (stim.split('/')[2].split('_')[1].includes("m")){
                stim_type = "no-go"
                correct_key = null
            }

            // add transition trials
            var trial_transition = {
                type: jsPsychImageKeyboardResponse,
                stimulus: stim,
                choices: [' '],
                data: {
                    stimulus_type: stim_type,
                    correct_key: correct_key,
                    curr_level: 1,
                    curr_trial_duration: duration_levels_dict[1],
                    trial_number: i / 2,
                    game_type: "gradcpt",
                    practice: "true",
                    cpt_type: "transition"
                },
                prompt:"<div style='text-align: center; margin-top: 20px;'>Press Spacebar if it is a city.</div>",
                trial_duration:duration_levels_dict[1],
                response_ends_trial:false,
                render_on_canvas: false,
                on_finish: function(data){
                    // Score the response as correct or incorrect.
                    if(jsPsych.pluginAPI.compareKeys(data.response, data.correct_key)){
                        data.correct = true;
                    } else {
                        data.correct = false; 
                    }
                }
            };
            trials.push(trial_transition)
            continue
        } else { // that means adding an imaage trial
            if (stim.includes("mountain")){
                stim_type = "no-go"
                correct_key = null
            }
            // add image trials
            var trial_img = {
                type: jsPsychImageKeyboardResponse,
                stimulus: stim,
                choices: [' '],
                data: {
                    stimulus_type: stim_type,
                    correct_key: correct_key,
                    trial_number: i / 2,
                    curr_trial_duration: duration_levels_dict[level_for_all_trials],
                    game_type: "gradcpt",
                    practice: "true",
                    cpt_type: "img"
                },
                prompt:"<div style='text-align: center; margin-top: 20px;'>Press Spacebar if it is a city.</div>",
                // fix the step function so that if the transition was correct, it doesn't mean this specific image gets harder
                trial_duration: duration_levels_dict[level_for_all_trials],
                response_ends_trial:false,
                render_on_canvas: false,
                on_finish: function(data){
                    // first check if they got it correct during the previous transition trial
                    var prev_correct = jsPsych.data.get().last(2).values()[0].correct
                    
                    // Score the response as correct or incorrect.
                    if(jsPsych.pluginAPI.compareKeys(data.response, data.correct_key)){
                        data.correct = true;

                        if (data.stimulus_type == "no-go"){
                            data.correct = prev_correct
                        }
                    } else {
                        if (prev_correct){// if the transition was correct then it seeps onto the image trial
                            // unless its a mountain trial, then if they're wrong in image trial they're wrong
                            if (data.stimulus_type == "no-go") {
                                data.correct = false;
                            } else {
                                data.correct = true;
                            }
                        } else {
                            data.correct = false; 
                        }
                    }
                    data.curr_level = curr_trial_duration_level
                    data.curr_trial_duration = duration_levels_dict[curr_trial_duration_level]

                    var update_to = jsPsych.getProgressBarCompleted() + proportion_to_update
                    jsPsych.setProgressBar(update_to);
                }
            };
            trials.push(trial_img)
            continue
        }
    }
    
    // add final transition from prev image to white
    var trial_transition = {
        type: jsPsychImageKeyboardResponse,
        stimulus: final_list[num_items],
        choices: [' '],
        data: {
            stimulus_type: 'filler',
            correct_key: ' ',
            curr_level: 1,
            curr_trial_duration: duration_levels_dict[1],
            trial_number: i / 2,
            game_type: "gradcpt",
            practice: "true",
            cpt_type: "transition"
        },
        prompt:"<div style='text-align: center; margin-top: 20px;'>Ending now.</div>",
        trial_duration:duration_levels_dict[1],
        response_ends_trial:false,
        render_on_canvas: false,
    };
    trials.push(trial_transition)

    // add a feedback trial here
    var cpt_practice_feedback = {
        type: jsPsychHtmlKeyboardResponse,
        trial_duration: 2000,
        response_ends_trial:false,
        stimulus: function(){
            var cpt_practice_trials = jsPsych.data.get().filter({game_type:"gradcpt",practice:"true",cpt_type: "img"}).values();
            var num_cpt_practice_trials = cpt_practice_trials.length
            var accuracy_count = 0
            for (let i = 0; i < num_cpt_practice_trials; i++){
                if(cpt_practice_trials[i].correct){
                    accuracy_count += 1
                }
            }

            var accuracy =  num_trials > 0 ? (100 * accuracy_count / num_trials) : 0;
            
            jsPsych.data.get().addToLast({cpt_practice_accuracy: accuracy});// should I do something where if they get a lot wrong they have to do it again? or would this just be exclusion criteria?

            return '<div>You got ' + accuracy + '% correct </p>'
        }
      }
    
    trials.push(cpt_practice_feedback)

    // remove the items you used from the final_list array
    final_list.splice(0,num_items + 1)

    return trials
}

//////////////////////////////////////////////////////////////////////////////
//// TIMELINE CREATION

// ORDERED LIST OF STIMULI (length: totalTrialNum_gradcpt = practice_trials_gradcpt_num + num_blocks*gradcpt_trials_per_block = max possible number of gradCPT trials in this experiment)
// the num trials input here doesn't really do anything
var final_list = random_stimulus_list(totalTrialNum_gradcpt)

// PRACTICE TRIALS
var gradcpt_practice_trials = {
    timeline: getTrials_practice_gradcpt(practice_trials_gradcpt_num)
}
////////////////////////////////////////////
// instructions files
// WELCOME TO EXPERIMENT
var welcome_practice_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>Welcome to this experiment! In this experiment, you will be doing two tasks. Before we begin the actual experiment, let\'s do some practice trials.</p><br>\
      We will begin with the first game."
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next'
  }

// #TODO CONSENT FORM
var consent_form = {
  type: jsPsychSurveyMultiChoice,
  preamble: '<p>Welcome! Thank you for agreeing to take part in the pilot version of this study. If you consent to participating, please click the option below. If not, please exit out of the experiment.</p>',
  questions: [
    {
      prompt: "Are you willing to take part in this study?", 
      name: 'Consent_response', 
      options: ['I agree to take part in this study.'], 
      required: true,
      horizontal: true
    }, 
  ],
  on_start: function(){
    document.getElementById("jspsych-progressbar-container").style.visibility = "hidden";
  }
}

// SPATIAL RECALL TASK INSTRUCTIONS (before each SR block)
var sr_task_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>Welcome to the spatial recall game! Click next for the instructions.</p>",
      "<p>In this game you will see a grid of squares that will flash blue one at a time.</p><p>Your goal is to remember the order in which the squares flashed blue.</p><p>At the end of each trial, press the tiles that flashed in the <b>same order</b> as they were presented to you.</p>",
      `<p>Do your best to memorize the order, but do not write them down<br>or use any other external tool to help you remember.</p><p>If you make a mistake, click the "Clear" button to erase your entries.</p><p>When you're ready, click "Next" to get started.</p>`
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next',
    on_finish: function(){
      document.getElementById("jspsych-progressbar-container").style.visibility = "visible";
      jsPsych.setProgressBar(0);
    }
  }

  // TRANSITION BETWEEN GAMES IN PRACTICE SESSION
  var practice_transition = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: '<p> Great work! You will now have practice for the next game. Press any key to continue. </p>',
    choices: "ALL_KEYS",
    on_start: function(){
      document.getElementById("jspsych-progressbar-container").style.visibility = "hidden";
    }
    //trial_duration: 1200,
  }

// GRADCPT TASK INSTRUCTIONS (before each gradcpt block)
var cpt_task_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>Welcome to the gradual onset game! Click next for the instructions.</p>",
      "<p>In this task, an image will appear in the center of the screen.</p><p>\
      If the image is a <strong>city</strong> press Spacebar on the keyboard as fast as you can.</p><p>\
      If the image is a <strong>mountain</strong>, do not press a key.</p>\
      <div style='width: 700px;'><div style='float: left;'><img src='./img900_esterman_w_big/city_1.jpg'></img>\
      <p class='small'><strong>Press the Space key</strong></p></div>\
      <div style='float: right;'><img src='./img900_esterman_w_big/mountain_1.jpg'></img>\
      <p class='small'><strong>Do not press a key</strong></p></div>\
      </div>",
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next'
  }

var gradcpt_quiz = {
  type: jsPsychSurveyMultiChoice,
  questions: [
    {
      prompt: "For this game, I should:", 
      name: 'gradcpt_question', 
      options: ['Press the Enter key for a city, and nothing for a mountain', 'Press the Space key for a city, and nothing for a mountain', 'Press the Space key for all images'], 
      required: true
    }
  ],
};

var gradcpt_begin = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: 'The correct answer is to press the Space key when you see a city, and nothing when you see a mountain. <br><br> When you are ready, press any key to continue to the game.</p>',
  choices: "ALL_KEYS",
  on_finish: function(){
    document.getElementById("jspsych-progressbar-container").style.visibility = "visible";
    jsPsych.setProgressBar(0);
  }
  //trial_duration: 1200,
}


// MAIN EXPERIMENT INSTRUCTIONS + BDM
var main_exp_BDM_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>We will now go into instructions for the main experiment.</p>",
      "<p>You will be given a monetary bonus based on your accuracy in this experiment.\
      You will not be shown the bonus until the end.</p><p>",
      "<p>You will be also be given an endowment of <strong>1000</strong> points which you can use throughout the game </p>",
      "<p>In this experiment, you will be switching between the two games you practiced earlier. You will occasionally be asked how many points \
      (from 1 to 100) you are willing to offer in order to switch to the other game (these points will come from your endowment).</p>",
      "<p>Think of this like an <strong>auction</strong>. <br><br>\
      We will randomly select a value from 1 to 100 each time you are given the option to switch. Let's call this <strong> our bid </strong> <br><br> \
      <strong> If the number of points you offer </strong> is \
      <strong> larger </strong> than our bid, <strong> you will get to switch games</strong>, and <strong>you will only pay our bid value </strong>\
      (even if your offer was significantly higher).<br><br>\
      <strong>If the value you offer </strong> is <strong>lower</strong> than our bid value, <strong>you will continue playing \
      your current game</strong>. Because of this,<strong> it is to your benefit to be honest in how much you are willing to pay</strong>.</p>",
      "<p>You will now be asked to answer a few questions about this, so feel free to re-read the instructions before you click Next </p>"
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next',
    on_start: function(){
      document.getElementById("jspsych-progressbar-container").style.visibility = "hidden";
    }
  }

// BDM QUIZ
var BDM_quiz = {
    type: jsPsychSurveyMultiChoice,
    questions: [
      {
        prompt: "Every time I get the option to switch, my offer will be compared to a randomly selected bid. Which of the following is true:", 
        name: 'BDM_gen', 
        options: ['This randomly selected bid is the same throughout the experiment.','This randomly selected bid gets re-generated every time I am given the option to switch.','This randomly selected bid will always be larger than mine.'], 
        required: true
      },
      {
        prompt: "When I get the option to switch, the points I'm offering come from:", 
        name: 'BDM_points', 
        options: ['My initial endowment of points.','The points I have gained from being accurate in the experiment so far.','They come from nowhere. I have an infinite amount of points to give.'], 
        required: true
      },
      {
        prompt: "To get the best result when it comes to switching, I should:", 
        name: 'BDM_should', 
        options: ['Always offer a higher number of points than I would really want to trade to switch.', 'Always offer a lower number of points than I would really want to trade to switch.', 'Always be honest about exactly how many points I would be willing to trade.'], 
        required: true
      },
    ],
    randomize_question_order: false,
  };

  var BDM_quiz_answers = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: '<p> The correct answers are: <br><br> 1. The randomly selected bid that your offer will be compared to \
    will be re-generated every time you get the option to switch. <br><br>\
     2. The points you offer when you get the option to switch come from your initial endowment of points.<br><br>\
     3. To get the best results when it comes to switching, you should always be honest about exactly how many points \
     you would be willing to trade. <br><br> Press any key to continue. </p>',
    choices: "ALL_KEYS",
    trial_duration: 5000,
  }

var final_exp_instructions = {
    type: jsPsychInstructions,
    pages: [
      "<p>Great! You are now ready to begin.</p>",
      "<p>As a reminder, in this experiment you will start off with playing one of the two games you previously practiced.\
      <br><br>You will also occasionally be asked \
      how many points you would be willing to trade to switch to the other game. \
      <br><br>If your answer is higher than our randomly generated one, you will be switched! \
      If not, you will stay on this game</p>",
      "<p>When you're ready, press Next to begin</p>",
    ],
    key_forward: 'ArrowRight',
    key_backward: 'ArrowLeft',
    allow_keys: true,
    show_clickable_nav: true,
    button_label_previous: 'Prev',
    button_label_next: 'Next',
    on_finish: function(){
      document.getElementById("jspsych-progressbar-container").style.visibility = "visible";
      jsPsych.setProgressBar(0);
    }
}

/////////////////////////////
/// main experiment file

// INITIALIZE TIMELINE
var timeline = [];

// PRELOADS
// timeline.push(preload_auto, preload_manual)
timeline.push(preload_manual_instr)

// INTRUCTIONS AND PRACTICE SESSION
timeline.push(consent_form,welcome_practice_instructions,sr_task_instructions,sr_recall_forwards_practice,practice_transition,cpt_task_instructions,gradcpt_quiz,gradcpt_begin,gradcpt_practice_trials)

// MAIN EXPERIMENT INSTRUCTIONS
timeline.push(main_exp_BDM_instructions, BDM_quiz, BDM_quiz_answers, final_exp_instructions)

///////////////////////////////////////////////////////////
// MAIN EXPERIMENT
var generated_value = Math.floor(Math.random() * 101);
var currentTask = "spatial_recall" //(50% chance of either task being the first block) // other option is "gradcpt"
if (Math.random() < 0.5) {
    currentTask = "gradcpt"
}
var nextSwitch = false // update this in the on_finish of the switch_offer_screen
var repeat_loop = false

// SWITCH OFFER SCREEN (where participants type in their offer instead of a sliding scale)
var repeat_message = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: '<p style="font-size:40px;">Sorry, that was not a number between 1 and 100.</p><p style="font-size:40px;">Please press any key to try again.</p>',
    choices: "ALL_KEYS",
    trial_duration: 2000,
};
var switch_offer_screen = {
    type: jsPsychSurveyText,
    preamble: '<div style="width:500px;"><p>How many points do you want to offer to switch games?</p></div>',
    questions: [
        {prompt: 'Enter a number from 1 to 100 here: ', name: 'bid',required: true,}
    ],
    button_label: 'Submit bid',
    on_start: function(switch_offer_screen) {
        generated_value =  Math.floor(Math.random() * 101);
        document.getElementById("jspsych-progressbar-container").style.visibility = "hidden";
    },
    on_finish: function(data){
        cpt_ran = false
        var trade_value = jsPsych.data.get().last(1).values()[0].response.bid
        var ans = parseInt(trade_value)
        if (!(isNaN(ans) | ans < 1 | ans > 100)) {
            data.generated_BDM_value = generated_value
            data.blocks_completed = curr_block
            data.prevBlockType = currentTask

            if (trade_value >= generated_value) {
                nextSwitch = true

                if (currentTask == "spatial_recall") {
                    currentTask = "gradcpt"
                } else if (currentTask == "gradcpt") {
                    currentTask = "spatial_recall"
                }
            } else {
                nextSwitch = false
            }

            data.switch_next_block = nextSwitch

            document.getElementById("jspsych-progressbar-container").style.visibility = "visible";
            jsPsych.setProgressBar(0);
        } else {
            console.log("not valid")
        }
    }
}
var repeat_message_conditional = {
    timeline: [repeat_message],
    conditional_function: function() {
        // get last response
        var response = jsPsych.data.get().last(1).values()[0].response.bid
        // convert from text to number
        var response_num = parseInt(response);
        if (isNaN(response_num) | response_num < 1 | response_num > 100) {
            repeat_loop = true
            // return true to show the repeat_message trial
            return true;
        } else {
            repeat_loop = false
            // return false to skip the repeat_message trial
            return false;
        }
    }
}
var number_loop = {
    timeline: [switch_offer_screen, repeat_message_conditional],
    loop_function: function() {
        // repeat this timeline if 'repeat_loop' is true
        // don't repeat this timeline if 'repeat_loop' is false
        return repeat_loop;
    }
}

// final debrief 
var calculate_bonus = function(){
    // get grad cpt trials which are NOT practice and which are img trials (these have updated correctness info)
    // can try doing .select('correct')
    var gradcpt_img_trials = jsPsych.data.get().filter({game_type:"gradcpt",practice:"false",cpt_type: "img"}).values();

    // get sr trials which are NOT practice
    // can try doing .select("score_an")
    var sr_trials = jsPsych.data.get().filter({game_type:"spatial_recall",practice:"false"}).values();

    // get their accuracies
    var accuracy_count = 0
    var sr_len = sr_trials.length
    var gradcpt_len = gradcpt_img_trials.length
    for (let i = 0; i < sr_len;i++) {
        accuracy_count = accuracy_count + sr_trials[i].score_an
    }
    for (let i = 0; i < gradcpt_len; i++){
        if(gradcpt_img_trials[i].correct){
            accuracy_count += 1
        }
    }

    // for now let's say 35 cents per correct answer
    var total_trials = sr_len + gradcpt_len
    var accuracy_calc = total_trials > 0 ? (accuracy_count / total_trials) : 0;    
    var final_bonus = (accuracy_count * dollars_per_correct_bonus).toFixed(2)

    console.log(gradcpt_len)
    console.log(sr_len)
    console.log(accuracy_calc)
    console.log(accuracy_count)
    console.log(total_trials)
    console.log(final_bonus)

    // add the final accuracy and bonus to data
    jsPsych.data.get().addToLast({bonus: final_bonus,overall_accuracy: accuracy_calc});

    return final_bonus
}

var overall_debrief = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: 
      `<p>Thanks for participating! This experiment seeked to understand how cognitive fatigue, \
      effort, errors, and task switching interact. Your final bonus (based purely on how correct you \
    were) is <strong>insert</strong>. The experiment is over now, press any button to continue</p>`,
    on_start: function(overall_debrief) {
        var bonus = calculate_bonus()

        document.getElementById("jspsych-progressbar-container").style.visibility = "hidden";

        overall_debrief.stimulus = "<p>Thanks for participating! This experiment seeked to understand how cognitive fatigue, \
            effort, errors, and task switching interact. Your final bonus (based purely on how correct you \
          were) is $<strong>" + bonus + " dollars </strong>. The experiment is over now, press any button to continue</p>"
    }
}

// task switch or stay trials
var switchingGamesNotification = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: 'You will now switch to a new game',
    choices: 'NO_KEYS',  // No responses allowed
    trial_duration: 1000,
    on_start: function(switchingGamesNotification) {
        document.getElementById("jspsych-progressbar-container").style.visibility = "hidden";
        if (curr_block >= num_blocks){
            switchingGamesNotification.stimulus = "Great work! We will now debrief you."
        } else if (nextSwitch == false) {
            console.log("stay in same game")
            switchingGamesNotification.stimulus = "You will now stay in the same game."
        }
    },
    on_finish: function(){
        cpt_ran = false
        document.getElementById("jspsych-progressbar-container").style.visibility = "visible";
        jsPsych.setProgressBar(0);
    }
};

// prepare each potential block
var cpt_blocks = []
for (let i = 0; i < num_blocks; i++){
    var temp_block = {
        timeline: getTrials_gradcpt(gradcpt_trials_per_block),
    }
    cpt_blocks.push(temp_block)
}

var sr_block_trials = {
    timeline: sr_getBlock()
}
var full_gradcpt_block = {
    timeline: cpt_blocks[0]
}
var full_sr_block = {
    timeline: [sr_block_trials]
}

// FIRST BLOCK ADD MANUALLY
if (curr_block == 0 && currentTask == "spatial_recall") {
    timeline.push(full_sr_block,number_loop,switchingGamesNotification)
    curr_block = curr_block + 1
} else {
    timeline.push(cpt_blocks[0],number_loop,switchingGamesNotification)
    curr_block = curr_block + 1
    cpt_ran = true
}

// IF NODES FOR REST OF THE BLOCKS
// make an if node per cpt block
cpt_if_nodes = []
for (let i = 0; i < num_blocks; i++){
    var temp_if = {
        timeline: [cpt_blocks[i]],
        conditional_function: function(){// if return true, this timeline gets run if not it gets skipped
            // currentTask will get updated in the switch_offer_screen on finish, so don't need to worry about switch or no switch here
            if (curr_block != i || (cpt_ran == true)){
                cpt_ran = false
                return false
            } else {
                //curr_block = curr_block + 1
                cpt_ran = true
                return true
            } 
        }
    }
    cpt_if_nodes.push(temp_if)
}

var if_cpt_node = {
    timeline: cpt_if_nodes,
    conditional_function: function(){
        if (curr_block == num_blocks || currentTask == "spatial_recall" || (cpt_ran==true)){
            return false
        } else {
            cpt_ran = false
            return true
        }
    },
    on_finish: function(){
        curr_block = curr_block + 1
    }
}
var if_sr_node = {
    timeline: [full_sr_block],
    conditional_function: function(){// if return true, this timeline gets run if not it gets skipped
        cpt_ran = false
        // currentTask will get updated in the switch_offer_screen on finish, so don't need to worry about switch or no switch here
        if (curr_block == num_blocks || currentTask == "gradcpt"){
            return false
        } else {
            curr_block = curr_block + 1
            return true
        }
    }
}

var if_debrief_node = {
    timeline: [overall_debrief],
    conditional_function: function() {
        if (curr_block == num_blocks){
            return true
        } else {
            return false
        }
    }
}

// add the main experiment
var main_loop = {
    timeline: [if_cpt_node,if_sr_node,number_loop,switchingGamesNotification,if_debrief_node],
    loop_function: function(data){
        if (curr_block >= num_blocks) {
            return false
        } else {
            return true
        }
    }
}
timeline.push(main_loop)

// RUN THE EXPERIMENT
jsPsych.run(timeline);